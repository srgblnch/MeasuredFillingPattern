#!/usr/bin/env python
# -*- coding:utf-8 -*- 


##############################################################################
## license :
##============================================================================
##
## File :        FillingPatternFCT.py
## 
## Project :     Filling Pattern from the FCT
##
## This file is part of Tango device class.
## 
## Tango is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
## 
## Tango is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
## 
## You should have received a copy of the GNU General Public License
## along with Tango.  If not, see <http://www.gnu.org/licenses/>.
## 
##
## $Author :      sblanch$
##
## $Revision :    $
##
## $Date :        $
##
## $HeadUrl :     $
##============================================================================
##            This file is generated by POGO
##    (Program Obviously used to Generate tango Object)
##
##        (c) - Software Engineering Group - ESRF
##############################################################################

"""Device to ..."""

__all__ = ["FillingPatternFCT", "FillingPatternFCTClass", "main"]

__docformat__ = 'restructuredtext'

import PyTango
import sys
# Add additional import
#----- PROTECTED REGION ID(FillingPatternFCT.additionnal_import) ENABLED START -----#
import time
import threading
from BunchAnalyzer import BunchAnalyzer

META = u"""
    $URL: https://svn.code.sf.net/p/tango-ds/code/Servers/Calculation/FillingPatternFCT/src/FillingPatternFCT.py $
    $LastChangedBy: sergiblanch $
    $Date: 2012-12-12 11:33:48 +0100 (Wed, 12 Dec 2012)$
    $Rev: 5901 $
    License: GPL3+
    Author: Sergi Blanch
""".encode('latin1')

#FIXME: stablish default initial values
DEFAULT_NACQUSITIONS = 30
DEFAULT_STARTINGPOINT = 907
DEFAULT_SCOPESAMPLERATE = 40.0e10
MAX_SIZE_CYCLIC_BUFFER = 250
ALARM_SIZE_CYCLIC_BUFFER = 50

#----- PROTECTED REGION END -----#	//	FillingPatternFCT.additionnal_import

## Device States Description
## ALARM : Check the status, something is not running as expected, but the calculations are still alive.
## OFF : The device is alive, but is not reading anything, neither doing any calculation
## ON : Device is doing the calculation normally
## STANDBY : The calculation have start, but not with the expected #samples in the cyclic buffer 
## FAULT : Something out of the specs, calculation stopped. Check the status.
## INIT : Just when the device is launched until its build procedure is done

class FillingPatternFCT (PyTango.Device_4Impl):

    #--------- Add you global variables here --------------------------
    #----- PROTECTED REGION ID(FillingPatternFCT.global_variables) ENABLED START -----#
    def cleanAllImportantLogs(self):
        #@todo: clean the important logs when they loose importance.
        self.debug_stream("In %s::cleanAllImportantLogs()"%self.get_name())
        self._important_logs = []
        self.addStatusMsg("")

    def addStatusMsg(self,current,important = False):
        self.debug_stream("In %s::addStatusMsg()"%self.get_name())
        msg = "The device is in %s state.\n"%(self.get_state())
        for ilog in self._important_logs:
            msg = "%s%s\n"%(msg,ilog)
        status = "%s%s\n"%(msg,current)
        self.set_status(status)
        self.push_change_event('Status',status)
        if important and not current in self._important_logs:
            self._important_logs.append(current)

    def change_state(self,newstate):
        self.debug_stream("In %s::change_state(%s)"%(self.get_name(),str(newstate)))
        self.set_state(newstate)
        self.push_change_event('State',newstate)
        self.cleanAllImportantLogs()

    def createThread(self):
        self.debug_stream("In %s::createThread()"%self.get_name())
        #TODO: check if the thread can be created or if it is already created
        if not self.get_state() in [PyTango.DevState.OFF]:
            return False
        if hasattr(self,'_thread') and self._thread and self._thread.isAlive():
            self.debug_stream("In %s::createThread(): Trying to start threading when is already started."%self.get_name())
            self.change_state(PyTango.DevState.FAULT)
            self.addStatusMsg("Try to start the calculation thread when is already running.",important=True)
            return False
        self.debug_stream("In %s::createThread(): Start calculation threading."%self.get_name())
        try:
            self._joinerEvent = threading.Event()#to communicate between threads
            self._joinerEvent.clear()
            self._startCmd = threading.Event()#Start command has been received
            self._startCmd.clear()
            if self.AutoStart:
                self._startCmd.set()
            self._stopCmd = threading.Event()#Stop command has been received
            self._stopCmd.clear()
            self._thread = threading.Thread(target=self.analyzerThread)
            self._thread.setDaemon(True)
            self._thread.start()
            self.debug_stream("In %s::createThread(): Thread created."%self.get_name())
        except Exception,e:
            self.warn_stream("In %s::createThread(): Exception creating thread: %s."%(self.get_name(),e))
            self.change_state(PyTango.DevState.FAULT)
            self.addStatusMsg("Exception creating calculation thread.",important=True)
            return False
        return True
    def deleteThread(self):
        self.debug_stream("In %s::deleteThread(): Stoping acquisition threading."%self.get_name())
        if hasattr(self,'_joinerEvent'):
            self.debug_stream("In %s::deleteThread(): sending join event."%self.get_name())
            self._joinerEvent.set()
        if hasattr(self,'_thread'):
            self.debug_stream("In %s::deleteThread(): Thread joining."%self.get_name())
            self._thread.join(1)
            if self._thread.isAlive():
                self.debug_stream("In %s::deleteThread(): Thread joined."%self.get_name())
    
    def analyzerThread(self):
        self.debug_stream("In %s::analyzerThread(): Thread started."%self.get_name())
        if not hasattr(self,'_joinerEvent'):
            raise Exception("Not possible to start the loop because it have not end condition")
#        self.change_state(PyTango.DevState.STANDBY)#FIXME: change the state when it starts to work
#        self.cleanAllImportantLogs()
#        self.addStatusMsg("Starting buffer population")
        #Build the analyzer object
        try:
            self._bunchAnalyzer = BunchAnalyzer(parent=self,
                                                timingDevName=self.erDev,
                                                scopeDevName=self.scoDev,
                                                nAcquisitions=self.attr_nAcquisitions_read,
                                                cyclicBuffer=self.attr_cyclicBuffer_read,
                                                startingPoint=self.attr_StartingPoint_read)
            self.attr_TimingTrigger_read = self._bunchAnalyzer.getDelayTick()
        except:
            self.change_state(PyTango.DevState.FAULT)
            self.addStatusMsg("Cannot build the analyzer",important=True)
            return
        try:
            self.readRfAttributes()
        except:
            self.debug_stream("Exception reading RF attrs")
        self.readScopeAttributes()
        while not self._joinerEvent.isSet():
            #TODO: passive wait until no new data is available
            #FIXME: can this start with less samples in the buffer than the 
            #       number configured in the nAcquisitions attribute?
            #TODO: if a loop takes too long ALARM state and a message
            try:
                if self._startCmd.isSet():
                    self._startCmd.clear()
                    if not self.get_state() in [PyTango.DevState.STANDBY,
                                                PyTango.DevState.ON]:
                        try:
                            # Subscribe to events of the scope channel
                            self._bunchAnalyzer.setCyclicBuffer([])
                            self._bunchAnalyzer.subscribe_event(self.FCTAttribute)
                        except Exception,e:
                            self.change_state(PyTango.DevState.FAULT)
                            self.addStatusMsg("Cannot subscribe to the FCT",important=True)
                            self.debug_stream("Cannot subscribe to the FCT due to: %s"%(e))
                if self._stopCmd.isSet():
                    self._stopCmd.clear()
                    if not self.get_state() in [PyTango.DevState.OFF]:
                        try:
                            self._bunchAnalyzer.unsubscribe_event()
                            eventList = []
                            eventList.append(['nAcquisitions',0])#,PyTango.AttrQuality.ATTR_INVALID])
                            eventList.append(['CyclicBuffer',[[0]]])#,PyTango.AttrQuality.ATTR_INVALID])
                            eventList.append(['BunchIntensity',[0]])#,PyTango.AttrQuality.ATTR_INVALID])
                            eventList.append(['FilledBunches',0])#,PyTango.AttrQuality.ATTR_INVALID])
                            eventList.append(['SpuriousBunches',0])#,PyTango.AttrQuality.ATTR_INVALID])
                            eventList.append(['resultingFrequency',0])#,PyTango.AttrQuality.ATTR_INVALID])
                            self.fireEventsList(eventList)
                        except Exception,e:
                            self.change_state(PyTango.DevState.FAULT)
                            self.addStatusMsg("Cannot unsubscribe to the FCT",important=True)
                            self.debug_stream("Cannot unsubscribe to the FCT due to: %s"%(e))
                time.sleep(1)
                #secundary attributes to read periodically and without events
                self.readRfAttributes()
                self.readScopeAttributes()
            except Exception,e:
                pass #TODO
            
    def fireEventsList(self,eventsAttrList):
        #self.debug_stream("In %s::fireEventsList()"%self.get_name())
        #@todo: add the value on the push_event
        timestamp = time.time()
        for attrEvent in eventsAttrList:
            try:
                self.debug_stream("In %s::fireEventsList() attribute: %s"%(self.get_name(),attrEvent[0]))
                if attrEvent[0] in ['CyclicBuffer'] and not self.attr_emitCyclicBuffer_read:
                    self.debug_stream("In %s::fireEventsList() attribute: %s avoided to emit the event duo to flag."%(self.get_name(),attrEvent[0]))
                elif len(attrEvent) == 3:#specifies quality
                    self.push_change_event(attrEvent[0],attrEvent[1],timestamp,attrEvent[2])
                else:
                    self.push_change_event(attrEvent[0],attrEvent[1],timestamp,PyTango.AttrQuality.ATTR_VALID)
            except Exception,e:
                self.error_stream("In %s::fireEventsList() Exception with attribute %s"%(self.get_name(),attrEvent[0]))
                print e

    def readRfAttributes(self):
        #if more than one, use read attributes
        self._bunchAnalyzer.setRfFrequency(PyTango.AttributeProxy(self.RfGeneratorDev+'/Frequency').read().value)

    def readScopeAttributes(self):
        try:
            attrs = self._bunchAnalyzer.getScopeDevice().read_attributes(['CurrentSampleRate',
                                                                         'ScaleH',
                                                                         'OffsetH'])
            self.debug_stream("SampleRate = %f"%attrs[0].value)
            self._bunchAnalyzer.setScopeSampleRate(attrs[0].value)
            self.scopeSampleRate = self._bunchAnalyzer.getScopeSampleRate()
            self.attr_ScaleH_read = attrs[1].value
            self.attr_OffsetH_read = attrs[2].value
        except Exception,e:
            self.debug_stream("Exception reading Scope attrs: %s"%e)

    #----- PROTECTED REGION END -----#	//	FillingPatternFCT.global_variables

    def __init__(self,cl, name):
        PyTango.Device_4Impl.__init__(self,cl,name)
        self.debug_stream("In __init__()")
        FillingPatternFCT.init_device(self)
        #----- PROTECTED REGION ID(FillingPatternFCT.__init__) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	FillingPatternFCT.__init__
        
    def delete_device(self):
        self.debug_stream("In delete_device()")
        #----- PROTECTED REGION ID(FillingPatternFCT.delete_device) ENABLED START -----#
        self.deleteThread()
        #----- PROTECTED REGION END -----#	//	FillingPatternFCT.delete_device

    def init_device(self):
        self.debug_stream("In init_device()")
        self.get_device_properties(self.get_device_class())
        self.attr_OffsetH_read = 0.0
        self.attr_ScaleH_read = 0.0
        self.attr_StartingPoint_read = 0
        self.attr_Threshold_read = 0.0
        self.attr_TimingTrigger_read = 0
        self.attr_nAcquisitions_read = 0
        self.attr_FilledBunches_read = 0
        self.attr_SpuriousBunches_read = 0
        self.attr_resultingFrequency_read = 0.0
        self.attr_emitCyclicBuffer_read = False
        self.attr_BunchIntensity_read = [0.0]
        self.attr_cyclicBuffer_read = [[0.0]]
        #----- PROTECTED REGION ID(FillingPatternFCT.init_device) ENABLED START -----#
        #self.attr_nAcquisitions_read = DEFAULT_NACQUSITIONS
        #self.attr_StartingPoint_read = DEFAULT_STARTINGPOINT
        self.CurrentSampleRate = DEFAULT_SCOPESAMPLERATE
        self._important_logs = []
        #prepare attributes that will have events
        self.set_change_event('State', True, False)
        self.set_change_event('Status', True, False)
        self.set_change_event('cyclicBuffer',True,False)
        self.set_change_event('nAcquisitions',True,False)
        self.set_change_event('BunchIntensity',True,False)
        self.set_change_event('FilledBunches',True,False)
        self.set_change_event('SpuriousBunches',True,False)
        self.set_change_event('resultingFrequency',True,False)
        self.change_state(PyTango.DevState.OFF)
        #prepare the analyzer thread
        if self.createThread():
            self.addStatusMsg("Analyzer thread well created")
        else:
            self.change_state(PyTango.DevState.FAULT)
            self.cleanAllImportantLogs()
            self.addStatusMsg("Analyzer thread cannot be created")
        #----- PROTECTED REGION END -----#	//	FillingPatternFCT.init_device

    def always_executed_hook(self):
        self.debug_stream("In always_excuted_hook()")
        #----- PROTECTED REGION ID(FillingPatternFCT.always_executed_hook) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	FillingPatternFCT.always_executed_hook

    #-----------------------------------------------------------------------------
    #    FillingPatternFCT read/write attribute methods
    #-----------------------------------------------------------------------------
    
    def read_OffsetH(self, attr):
        self.debug_stream("In read_OffsetH()")
        #----- PROTECTED REGION ID(FillingPatternFCT.OffsetH_read) ENABLED START -----#
        attr.set_value(self.attr_OffsetH_read)
        #----- PROTECTED REGION END -----#	//	FillingPatternFCT.OffsetH_read
        
    def write_OffsetH(self, attr):
        self.debug_stream("In write_OffsetH()")
        data=attr.get_write_value()
        #----- PROTECTED REGION ID(FillingPatternFCT.OffsetH_write) ENABLED START -----#
        self._bunchAnalyzer.getScopeDevice().write_attribute('OffsetH',data)
        #----- PROTECTED REGION END -----#	//	FillingPatternFCT.OffsetH_write
        
    def read_ScaleH(self, attr):
        self.debug_stream("In read_ScaleH()")
        #----- PROTECTED REGION ID(FillingPatternFCT.ScaleH_read) ENABLED START -----#
        attr.set_value(self.attr_ScaleH_read)
        #----- PROTECTED REGION END -----#	//	FillingPatternFCT.ScaleH_read
        
    def write_ScaleH(self, attr):
        self.debug_stream("In write_ScaleH()")
        data=attr.get_write_value()
        #----- PROTECTED REGION ID(FillingPatternFCT.ScaleH_write) ENABLED START -----#
        self._bunchAnalyzer.getScopeDevice().write_attribute('ScaleH',data)
        #----- PROTECTED REGION END -----#	//	FillingPatternFCT.ScaleH_write
        
    def read_StartingPoint(self, attr):
        self.debug_stream("In read_StartingPoint()")
        #----- PROTECTED REGION ID(FillingPatternFCT.StartingPoint_read) ENABLED START -----#
        self.attr_StartingPoint_read = self._bunchAnalyzer.getStartingPoint()
        attr.set_value(self.attr_StartingPoint_read)
        #----- PROTECTED REGION END -----#	//	FillingPatternFCT.StartingPoint_read
        
    def write_StartingPoint(self, attr):
        self.debug_stream("In write_StartingPoint()")
        data=attr.get_write_value()
        #----- PROTECTED REGION ID(FillingPatternFCT.StartingPoint_write) ENABLED START -----#
        self._bunchAnalyzer.setStartingPoint(int(data))
        #----- PROTECTED REGION END -----#	//	FillingPatternFCT.StartingPoint_write
        
    def read_Threshold(self, attr):
        self.debug_stream("In read_Threshold()")
        #----- PROTECTED REGION ID(FillingPatternFCT.Threshold_read) ENABLED START -----#
        self.attr_Threshold_read = self._bunchAnalyzer.getThreshold()
        attr.set_value(self.attr_Threshold_read)
        #----- PROTECTED REGION END -----#	//	FillingPatternFCT.Threshold_read
        
    def write_Threshold(self, attr):
        self.debug_stream("In write_Threshold()")
        data=attr.get_write_value()
        #----- PROTECTED REGION ID(FillingPatternFCT.Threshold_write) ENABLED START -----#
        self._bunchAnalyzer.setThreshold(float(data))
        #----- PROTECTED REGION END -----#	//	FillingPatternFCT.Threshold_write
        
    def read_TimingTrigger(self, attr):
        self.debug_stream("In read_TimingTrigger()")
        #----- PROTECTED REGION ID(FillingPatternFCT.TimingTrigger_read) ENABLED START -----#
        self.attr_TimingTrigger_read = self._bunchAnalyzer.getDelayTick()
        attr.set_value(self.attr_TimingTrigger_read)
        #----- PROTECTED REGION END -----#	//	FillingPatternFCT.TimingTrigger_read
        
    def write_TimingTrigger(self, attr):
        self.debug_stream("In write_TimingTrigger()")
        data=attr.get_write_value()
        #----- PROTECTED REGION ID(FillingPatternFCT.TimingTrigger_write) ENABLED START -----#
        self._bunchAnalyzer.setDelayTick(int(data))
        #----- PROTECTED REGION END -----#	//	FillingPatternFCT.TimingTrigger_write
        
    def read_nAcquisitions(self, attr):
        self.debug_stream("In read_nAcquisitions()")
        #----- PROTECTED REGION ID(FillingPatternFCT.nAcquisitions_read) ENABLED START -----#
        lenBuf = len(self._bunchAnalyzer.getCyclicBuffer())
        self.attr_nAcquisitions_read = self._bunchAnalyzer.getNAcquisitions()
        if lenBuf > ALARM_SIZE_CYCLIC_BUFFER:
            attr.set_value_date_quality(lenBuf,time.time(),PyTango.AttrQuality.ATTR_ALARM)
        elif lenBuf < self.attr_nAcquisitions_read:
            attr.set_value_date_quality(lenBuf,time.time(),PyTango.AttrQuality.ATTR_CHANGING)
        else:
            attr.set_value(self.attr_nAcquisitions_read)
        #----- PROTECTED REGION END -----#	//	FillingPatternFCT.nAcquisitions_read
        
    def write_nAcquisitions(self, attr):
        self.debug_stream("In write_nAcquisitions()")
        data=attr.get_write_value()
        #----- PROTECTED REGION ID(FillingPatternFCT.nAcquisitions_write) ENABLED START -----#
        if int(data) > MAX_SIZE_CYCLIC_BUFFER:
            PyTango.Except.throw_exception("maximum reached",
                                           "The maximum size of buffer is reached", "nAquisitions", sever=PyTango_ErrSeverity_ERR)
        self._bunchAnalyzer.setNAcquisitions(int(data))
        #----- PROTECTED REGION END -----#	//	FillingPatternFCT.nAcquisitions_write
        
    def read_FilledBunches(self, attr):
        self.debug_stream("In read_FilledBunches()")
        #----- PROTECTED REGION ID(FillingPatternFCT.FilledBunches_read) ENABLED START -----#
        self.attr_FilledBunches_read = self._bunchAnalyzer.getFilledBunches()
        attr.set_value(self.attr_FilledBunches_read)
        #----- PROTECTED REGION END -----#	//	FillingPatternFCT.FilledBunches_read
        
    def read_SpuriousBunches(self, attr):
        self.debug_stream("In read_SpuriousBunches()")
        #----- PROTECTED REGION ID(FillingPatternFCT.SpuriousBunches_read) ENABLED START -----#
        self.attr_SpuriousBunches_read = self._bunchAnalyzer.getSpuriousBunches()
        attr.set_value(self.attr_SpuriousBunches_read)
        #----- PROTECTED REGION END -----#	//	FillingPatternFCT.SpuriousBunches_read
        
    def read_resultingFrequency(self, attr):
        self.debug_stream("In read_resultingFrequency()")
        #----- PROTECTED REGION ID(FillingPatternFCT.resultingFrequency_read) ENABLED START -----#
        self.attr_resultingFrequency_read = self._bunchAnalyzer.getResultingFrequency()
        attr.set_value(self.attr_resultingFrequency_read)
        #----- PROTECTED REGION END -----#	//	FillingPatternFCT.resultingFrequency_read
        
    def read_emitCyclicBuffer(self, attr):
        self.debug_stream("In read_emitCyclicBuffer()")
        #----- PROTECTED REGION ID(FillingPatternFCT.emitCyclicBuffer_read) ENABLED START -----#
        attr.set_value(self.attr_emitCyclicBuffer_read)
        
        #----- PROTECTED REGION END -----#	//	FillingPatternFCT.emitCyclicBuffer_read
        
    def write_emitCyclicBuffer(self, attr):
        self.debug_stream("In write_emitCyclicBuffer()")
        data=attr.get_write_value()
        #----- PROTECTED REGION ID(FillingPatternFCT.emitCyclicBuffer_write) ENABLED START -----#
        self.attr_emitCyclicBuffer_read = bool(data)
        #----- PROTECTED REGION END -----#	//	FillingPatternFCT.emitCyclicBuffer_write
        
    def read_BunchIntensity(self, attr):
        self.debug_stream("In read_BunchIntensity()")
        #----- PROTECTED REGION ID(FillingPatternFCT.BunchIntensity_read) ENABLED START -----#
        self.attr_BunchIntensity_read = self._bunchAnalyzer.getBunchIntensity()
        attr.set_value(self.attr_BunchIntensity_read)
        #----- PROTECTED REGION END -----#	//	FillingPatternFCT.BunchIntensity_read
        
    def read_cyclicBuffer(self, attr):
        self.debug_stream("In read_cyclicBuffer()")
        #----- PROTECTED REGION ID(FillingPatternFCT.cyclicBuffer_read) ENABLED START -----#
        self.attr_cyclicBuffer_read = self._bunchAnalyzer.getCyclicBuffer()
        attr.set_value(self.attr_cyclicBuffer_read)
        #----- PROTECTED REGION END -----#	//	FillingPatternFCT.cyclicBuffer_read
        
    
    
        #----- PROTECTED REGION ID(FillingPatternFCT.initialize_dynamic_attributes) ENABLED START -----#
    def initialize_dynamic_attributes(self):
        pass
        #----- PROTECTED REGION END -----#	//	FillingPatternFCT.initialize_dynamic_attributes
            
    def read_attr_hardware(self, data):
        self.debug_stream("In read_attr_hardware()")
        #----- PROTECTED REGION ID(FillingPatternFCT.read_attr_hardware) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	FillingPatternFCT.read_attr_hardware


    #-----------------------------------------------------------------------------
    #    FillingPatternFCT command methods
    #-----------------------------------------------------------------------------
    
    def Start(self):
        """ 
        
        :param : 
        :type: PyTango.DevVoid
        :return: 
        :rtype: PyTango.DevVoid """
        self.debug_stream("In Start()")
        #----- PROTECTED REGION ID(FillingPatternFCT.Start) ENABLED START -----#
        self._startCmd.set()
        #----- PROTECTED REGION END -----#	//	FillingPatternFCT.Start
        
    def Stop(self):
        """ 
        
        :param : 
        :type: PyTango.DevVoid
        :return: 
        :rtype: PyTango.DevVoid """
        self.debug_stream("In Stop()")
        #----- PROTECTED REGION ID(FillingPatternFCT.Stop) ENABLED START -----#
        self._stopCmd.set()
        #----- PROTECTED REGION END -----#	//	FillingPatternFCT.Stop
        

class FillingPatternFCTClass(PyTango.DeviceClass):
    #--------- Add you global class variables here --------------------------
    #----- PROTECTED REGION ID(FillingPatternFCT.global_class_variables) ENABLED START -----#
    
    #----- PROTECTED REGION END -----#	//	FillingPatternFCT.global_class_variables

    def dyn_attr(self, dev_list):
        """Invoked to create dynamic attributes for the given devices.
        Default implementation calls
        :meth:`FillingPatternFCT.initialize_dynamic_attributes` for each device
    
        :param dev_list: list of devices
        :type dev_list: :class:`PyTango.DeviceImpl`"""
    
        for dev in dev_list:
            try:
                dev.initialize_dynamic_attributes()
            except:
                import traceback
                dev.warn_stream("Failed to initialize dynamic attributes")
                dev.debug_stream("Details: " + traceback.format_exc())
        #----- PROTECTED REGION ID(FillingPatternFCT.dyn_attr) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	FillingPatternFCT.dyn_attr

    #    Class Properties
    class_property_list = {
        }


    #    Device Properties
    device_property_list = {
        'erDev':
            [PyTango.DevString,
            "Event Receiver Device name",
            [] ],
        'FCTAttribute':
            [PyTango.DevString,
            "Channel of the scope from where the readings are get",
            [] ],
        'scoDev':
            [PyTango.DevString,
            "Scope Device name where one channel has the FCT signal",
            [] ],
        'AutoStart':
            [PyTango.DevBoolean,
            "Configure if the device must start the calculation by default when it is launched",
            [True]],
        'RfGeneratorDev':
            [PyTango.DevString,
            "RfGenerator Device name from where the frequency is read from time to time",
            [] ],
        }


    #    Command definitions
    cmd_list = {
        'Start':
            [[PyTango.DevVoid, "none"],
            [PyTango.DevVoid, "none"]],
        'Stop':
            [[PyTango.DevVoid, "none"],
            [PyTango.DevVoid, "none"]],
        }


    #    Attribute definitions
    attr_list = {
        'OffsetH':
            [[PyTango.DevDouble,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'unit': "s",
                'format': "%3.9f",
                'description': "Oscilloscope Horizontal Offset",
                'Display level': PyTango.DispLevel.EXPERT,
                'Memorized':"true"
            } ],
        'ScaleH':
            [[PyTango.DevDouble,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'unit': "s/div",
                'format': "%3.9f",
                'description': "Oscilloscope Horizontal Scale",
                'Display level': PyTango.DispLevel.EXPERT,
                'Memorized':"true"
            } ],
        'StartingPoint':
            [[PyTango.DevLong64,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'Display level': PyTango.DispLevel.EXPERT,
                'Memorized':"true"
            } ],
        'Threshold':
            [[PyTango.DevDouble,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'unit': "%",
                'max value': "100",
                'min value': "0",
                'Memorized':"true_without_hard_applied"
            } ],
        'TimingTrigger':
            [[PyTango.DevULong,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'unit': "ticks",
                'Display level': PyTango.DispLevel.EXPERT,
                'Memorized':"true_without_hard_applied"
            } ],
        'nAcquisitions':
            [[PyTango.DevUShort,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'description': "Number of elements in the cyclic buffer from where the calculation takes the data.",
                'Memorized':"true"
            } ],
        'FilledBunches':
            [[PyTango.DevULong,
            PyTango.SCALAR,
            PyTango.READ]],
        'SpuriousBunches':
            [[PyTango.DevULong,
            PyTango.SCALAR,
            PyTango.READ]],
        'resultingFrequency':
            [[PyTango.DevDouble,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'unit': "Hz",
                'format': "%3.3f",
                'description': "Expert attribute to read the frequency with this device is pushing results in the output",
                'Display level': PyTango.DispLevel.EXPERT,
            } ],
        'emitCyclicBuffer':
            [[PyTango.DevBoolean,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'description': "This boolean attribute is to allow or not to emit the events on the cyclic Buffer. This is because it can cause delay dou to be too big buffer",
                'Display level': PyTango.DispLevel.EXPERT,
                'Memorized':"true"
            } ],
        'BunchIntensity':
            [[PyTango.DevDouble,
            PyTango.SPECTRUM,
            PyTango.READ, 5000]],
        'cyclicBuffer':
            [[PyTango.DevDouble,
            PyTango.IMAGE,
            PyTango.READ, 40000, MAX_SIZE_CYCLIC_BUFFER],
            {
                'description': "Expert attribute to be able to check the cyclic buffer evolution",
                'Display level': PyTango.DispLevel.EXPERT,
            } ],
        }


def main():
    try:
        py = PyTango.Util(sys.argv)
        py.add_class(FillingPatternFCTClass,FillingPatternFCT,'FillingPatternFCT')

        U = PyTango.Util.instance()
        U.server_init()
        U.server_run()

    except PyTango.DevFailed,e:
        print '-------> Received a DevFailed exception:',e
    except Exception,e:
        print '-------> An unforeseen exception occured....',e

if __name__ == '__main__':
    main()
