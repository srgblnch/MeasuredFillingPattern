#!/usr/bin/env python
# -*- coding:utf-8 -*- 


##############################################################################
## license : GPLv3+
##============================================================================
##
## File :        MeasuredFillingPatternFCT.py
## 
## Project :     Measure the Filling Pattern from the FCT signal taken from an
##               scope and 2 auxiliar devices more (timing and RF oscillator).
##
## $Author :      sblanch$
##
## $Revision :    $
##
## $Date :        $
##
## $HeadUrl :     $
##============================================================================
##            This file is generated by POGO
##    (Program Obviously used to Generate tango Object)
##
##        (c) - Controls Software Section - Alba synchrotron (cells)
##############################################################################

"""Device to ..."""

__all__ = ["MeasuredFillingPatternFCT", "MeasuredFillingPatternFCTClass", "main"]

__docformat__ = 'restructuredtext'

import PyTango
import sys
# Add additional import
#----- PROTECTED REGION ID(MeasuredFillingPatternFCT.additionnal_import) ENABLED START -----#
import time
import threading
from BunchAnalyzer import BunchAnalyzer
import traceback

from types import StringType

META = u"""
    $URL: https://svn.code.sf.net/p/tango-ds/code/Servers/Calculation/MeasuredFillingPatternFCT $
    $LastChangedBy: sergiblanch $
    License: GPL3+
    Author: Sergi Blanch
""".encode('latin1')

#FIXME: stablish default initial values
DEFAULT_NACQUSITIONS = 30
DEFAULT_STARTINGPOINT = 0
DEFAULT_SCOPESAMPLERATE = 40.0e10
MAX_SIZE_CYCLIC_BUFFER = 100
ALARM_SIZE_CYCLIC_BUFFER = 50

DEFAULT_CYCLIC_BUFFER_TRACE = 1000

#----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.additionnal_import

##############################################################################
## Device States Description
##
## ALARM : Check the status, something is not running as expected, but the calculations are still alive.
## OFF : The device is alive, but is not reading anything, neither doing any calculation
## ON : Device is doing the calculation normally
## STANDBY : The calculation have start, but not with the expected #samples in the cyclic buffer 
## FAULT : Something out of the specs, calculation stopped. Check the status.
## INIT : Just when the device is launched until its build procedure is done
##############################################################################

class MeasuredFillingPatternFCT (PyTango.Device_4Impl):

#--------- Add you global variables here --------------------------
#----- PROTECTED REGION ID(MeasuredFillingPatternFCT.global_variables) ENABLED START -----#
    def cleanAllImportantLogs(self):
        #@todo: clean the important logs when they loose importance.
        self.debug_stream("In %s::cleanAllImportantLogs()"%self.get_name())
        self._important_logs = []
        self.addStatusMsg("")

    def addStatusMsg(self,current,important = False):
        self.debug_stream("In %s::addStatusMsg()"%self.get_name())
        msg = "The device is in %s state.\n"%(self.get_state())
        for ilog in self._important_logs:
            msg = "%s%s\n"%(msg,ilog)
        status = "%s%s\n"%(msg,current)
        self.set_status(status)
        self.push_change_event('Status',status)
        if important and not current in self._important_logs:
            self._important_logs.append(current)

    def change_state(self,newstate):
        self.debug_stream("In %s::change_state(%s)"%(self.get_name(),str(newstate)))
        self.set_state(newstate)
        self.push_change_event('State',newstate)
        self.cleanAllImportantLogs()

    def createThread(self):
        self.debug_stream("In %s::createThread()"%self.get_name())
        #TODO: check if the thread can be created or if it is already created
        if not self.get_state() in [PyTango.DevState.OFF]:
            return False
        if hasattr(self,'_thread') and self._thread and self._thread.isAlive():
            self.debug_stream("In %s::createThread(): Trying to start threading when is already started."%self.get_name())
            self.change_state(PyTango.DevState.FAULT)
            self.addStatusMsg("Try to start the calculation thread when is already running.",important=True)
            return False
        self.debug_stream("In %s::createThread(): Start calculation threading."%self.get_name())
        try:
            self._joinerEvent = threading.Event()#to communicate between threads
            self._joinerEvent.clear()
            self._startCmd = threading.Event()#Start command has been received
            self._startCmd.clear()
            if self.AutoStart:
                self._startCmd.set()
            self._stopCmd = threading.Event()#Stop command has been received
            self._stopCmd.clear()
            self._thread = threading.Thread(target=self.analyzerThread)
            self._thread.setDaemon(True)
            self._thread.start()
            self.debug_stream("In %s::createThread(): Thread created."%self.get_name())
        except Exception,e:
            self.warn_stream("In %s::createThread(): Exception creating thread: %s."%(self.get_name(),e))
            self.change_state(PyTango.DevState.FAULT)
            self.addStatusMsg("Exception creating calculation thread.",important=True)
            return False
        return True
    def deleteThread(self):
        self.debug_stream("In %s::deleteThread(): Stoping acquisition threading."%self.get_name())
        if hasattr(self,'_joinerEvent'):
            self.debug_stream("In %s::deleteThread(): sending join event."%self.get_name())
            self._joinerEvent.set()
        if hasattr(self,'_thread'):
            self.debug_stream("In %s::deleteThread(): Thread joining."%self.get_name())
            self._thread.join(1)
            if self._thread.isAlive():
                self.debug_stream("In %s::deleteThread(): Thread joined."%self.get_name())
    
    def analyzerThread(self):
        self.debug_stream("In %s::analyzerThread(): Thread started."%self.get_name())
        if not hasattr(self,'_joinerEvent'):
            raise Exception("Not possible to start the loop because it have not end condition")
#        self.change_state(PyTango.DevState.STANDBY)#FIXME: change the state when it starts to work
#        self.cleanAllImportantLogs()
#        self.addStatusMsg("Starting buffer population")
        #Build the analyzer object
        try:
            time.sleep(1)
            self.debug_stream("Build BunchAnalyser instance")
            self._bunchAnalyzer = BunchAnalyzer(parent=self,
                                timingDevName=self.erDev,
                                delayTick=self.attr_TimingTrigger_read,
                                scopeDevName=self.scoDev,
                                cyclicBuffer=self.attr_cyclicBuffer_read,
                                threshold=self.attr_Threshold_write,
                                nAcquisitions=self.attr_nAcquisitions_write,
                                startingPoint=self.attr_StartingPoint_write,
                                max_cyclicBuf=MAX_SIZE_CYCLIC_BUFFER,
                                alarm_cyclicBuf=ALARM_SIZE_CYCLIC_BUFFER)
            self.debug_stream("Build BunchAnalyser made")
            self.attr_TimingTrigger_read = self._bunchAnalyzer.DelayTick
        except:
            self.change_state(PyTango.DevState.FAULT)
            self.addStatusMsg("Cannot build the analyzer",important=True)
            return
#        try:
#            self.readRfAttributes()
#        except:
#            self.debug_stream("Exception reading RF attrs")
#        self.readScopeAttributes()
        while not self._joinerEvent.isSet():
            #TODO: passive wait until no new data is available
            #FIXME: can this start with less samples in the buffer than the 
            #       number configured in the nAcquisitions attribute?
            #TODO: if a loop takes too long ALARM state and a message
            try:
                if self._startCmd.isSet():
                    self._startCmd.clear()
                    if not self.get_state() in [PyTango.DevState.STANDBY,
                                                PyTango.DevState.ON]:
                        try:
                            # Subscribe to events of the scope channel
                            self._bunchAnalyzer.CyclicBuffer = []
                            self._bunchAnalyzer.subscribe_event(self.FCTAttribute)
                        except Exception,e:
                            self.change_state(PyTango.DevState.FAULT)
                            self.addStatusMsg("Cannot subscribe to the FCT",important=True)
                            self.debug_stream("Cannot subscribe to the FCT due to: %s"%(e))
                if self._stopCmd.isSet():
                    self._stopCmd.clear()
                    if not self.get_state() in [PyTango.DevState.OFF]:
                        try:
                            self._bunchAnalyzer.unsubscribe_event()
                            eventList = []
                            eventList.append(['nAcquisitions',0])#,PyTango.AttrQuality.ATTR_INVALID])
                            eventList.append(['CyclicBuffer',[[0]]])#,PyTango.AttrQuality.ATTR_INVALID])
                            eventList.append(['BunchIntensity',[0]])#,PyTango.AttrQuality.ATTR_INVALID])
                            eventList.append(['FilledBunches',0])#,PyTango.AttrQuality.ATTR_INVALID])
                            eventList.append(['SpuriousBunches',0])#,PyTango.AttrQuality.ATTR_INVALID])
                            eventList.append(['nBunches',0])#,PyTango.AttrQuality.ATTR_INVALID])
                            eventList.append(['resultingFrequency',0])#,PyTango.AttrQuality.ATTR_INVALID])
                            self.fireEventsList(eventList)
                        except Exception,e:
                            self.change_state(PyTango.DevState.FAULT)
                            self.addStatusMsg("Cannot unsubscribe to the FCT",important=True)
                            self.debug_stream("Cannot unsubscribe to the FCT due to: %s"%(e))
                time.sleep(1)
                #secundary attributes to read periodically and without events
#                self.readRfAttributes()
#                self.readScopeAttributes()
            except Exception,e:
                self.error_stream("In %s::analyzerThread(): Exception: %s"%(self.get_name(),e))
            
    def fireEventsList(self,eventsAttrList):
        #self.debug_stream("In %s::fireEventsList()"%self.get_name())
        #@todo: add the value on the push_event
        timestamp = time.time()
        for attrEvent in eventsAttrList:
            try:
                self.debug_stream("In %s::fireEventsList() attribute: %s"%(self.get_name(),attrEvent[0]))
                if attrEvent[0] in ['CyclicBuffer'] and not self.attr_emitCyclicBuffer_read:
                    self.debug_stream("In %s::fireEventsList() attribute: %s avoided to emit the event duo to flag."%(self.get_name(),attrEvent[0]))
                elif len(attrEvent) == 3:#specifies quality
                    self.push_change_event(attrEvent[0],attrEvent[1],timestamp,attrEvent[2])
                else:
                    self.push_change_event(attrEvent[0],attrEvent[1],timestamp,PyTango.AttrQuality.ATTR_VALID)
            except Exception,e:
                self.error_stream("In %s::fireEventsList() Exception with attribute %s"%(self.get_name(),attrEvent[0]))
                print e

#    def readRfAttributes(self):
#        #if more than one, use read attributes
#        if self._bunchAnalyzer != None:
#            self._bunchAnalyzer.RfFrequency(PyTango.AttributeProxy(self.RfGeneratorDev+'/Frequency').read().value)

#    def readScopeAttributes(self):
#        if self._bunchAnalyzer != None:
#            try:
#                device = self._bunchAnalyzer.ScopeDevice()
#                attrs = device.read_attributes(['CurrentSampleRate',
#                                                'ScaleH',
#                                                'OffsetH'])
#                self.debug_stream("SampleRate = %f"%attrs[0].value)
#                self._bunchAnalyzer.ScopeSampleRate(attrs[0].value)
#                self.scopeSampleRate = self._bunchAnalyzer.ScopeSampleRate()
#                self.attr_ScaleH_read = attrs[1].value
#                self.attr_OffsetH_read = attrs[2].value
#            except Exception,e:
#                self.debug_stream("Exception reading Scope attrs: %s"%e)

    def _cyclicBufferTracer(self,msg):
        now = time.strftime("%Y%m%d_%H%M%S")
        self.attr_CyclicBufferTrace_read.append("%s: %s"%(now,msg))
        #clean too old messages
        if len(self.attr_CyclicBufferTrace_read) > DEFAULT_CYCLIC_BUFFER_TRACE:
            self.attr_CyclicBufferTrace_read = self.attr_CyclicBufferTrace_read[-DEFAULT_CYCLIC_BUFFER_TRACE]

    #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.global_variables
#------------------------------------------------------------------
#    Device constructor
#------------------------------------------------------------------
    def __init__(self,cl, name):
        PyTango.Device_4Impl.__init__(self,cl,name)
        self.debug_stream("In " + self.get_name() + ".__init__()")
        MeasuredFillingPatternFCT.init_device(self)

#------------------------------------------------------------------
#    Device destructor
#------------------------------------------------------------------
    def delete_device(self):
        self.debug_stream("In " + self.get_name() + ".delete_device()")
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.delete_device) ENABLED START -----#
        self.deleteThread()
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.delete_device

#------------------------------------------------------------------
#    Device initialization
#------------------------------------------------------------------
    def init_device(self):
        self.debug_stream("In " + self.get_name() + ".init_device()")
        self.get_device_properties(self.get_device_class())
        self.attr_FilledBunches_read = 0
        self.attr_OffsetH_read = 0.0
        self.attr_OffsetH_expert_read = 0.0
        self.attr_ScaleH_read = 0.0
        self.attr_ScaleH_expert_read = 0.0
        self.attr_SpuriousBunches_read = 0
        self.attr_StartingPoint_read = 0
        self.attr_StartingPoint_expert_read = 0
        self.attr_Threshold_read = 0.0
        self.attr_Threshold_expert_read = 0.0
        self.attr_TimingTrigger_read = 0
        self.attr_TimingTrigger_expert_read = 0
        self.attr_emitCyclicBuffer_read = False
        self.attr_nAcquisitions_read = 0
        self.attr_nBunches_read = 0
        self.attr_resultingFrequency_read = 0.0
        self.attr_BunchIntensity_read = [0.0]
        self.attr_CyclicBufferTrace_read = ['']
        self.attr_cyclicBuffer_read = [[0.0]]
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.init_device) ENABLED START -----#
        self.attr_nAcquisitions_write = DEFAULT_NACQUSITIONS
        self.attr_StartingPoint_write = DEFAULT_STARTINGPOINT
        self.attr_Threshold_write = 0.0
        self.CurrentSampleRate = DEFAULT_SCOPESAMPLERATE
        self._bunchAnalyzer = None
        self._important_logs = []
        #tools for the Exec() cmd
        DS_MODULE = __import__(self.__class__.__module__)
        kM = dir(DS_MODULE)
        vM = map(DS_MODULE.__getattribute__, kM)
        self.__globals = dict(zip(kM, vM))
        self.__globals['self'] = self
        self.__globals['module'] = DS_MODULE
        self.__locals = {}
        #prepare attributes that will have events
        self.set_change_event('State', True, False)
        self.set_change_event('Status', True, False)
        #self.set_change_event('cyclicBuffer',True,False)
        self.set_change_event('nAcquisitions',True,False)
        self.set_change_event('BunchIntensity',True,False)
        self.set_change_event('FilledBunches',True,False)
        self.set_change_event('SpuriousBunches',True,False)
        self.set_change_event('nBunches',True,False)
        self.set_change_event('resultingFrequency',True,False)
        self.change_state(PyTango.DevState.OFF)
        #prepare the analyzer thread
        if self.createThread():
            self.addStatusMsg("Analyzer thread well created")
        else:
            self.change_state(PyTango.DevState.FAULT)
            self.cleanAllImportantLogs()
            self.addStatusMsg("Analyzer thread cannot be created")
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.init_device

#------------------------------------------------------------------
#    Always excuted hook method
#------------------------------------------------------------------
    def always_executed_hook(self):
        self.debug_stream("In " + self.get_name() + ".always_excuted_hook()")
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.always_executed_hook) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.always_executed_hook

#==================================================================
#
#    MeasuredFillingPatternFCT read/write attribute methods
#
#==================================================================

#------------------------------------------------------------------
#    Read FilledBunches attribute
#------------------------------------------------------------------
    def read_FilledBunches(self, attr):
        self.debug_stream("In " + self.get_name() + ".read_FilledBunches()")
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.FilledBunches_read) ENABLED START -----#
        try:
            self.attr_FilledBunches_read = self._bunchAnalyzer.FilledBunches
        except:
            self.warn_stream("In read_FilledBunches() cannot get from BunchAnalyzer()")
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.FilledBunches_read
        attr.set_value(self.attr_FilledBunches_read)
        
#------------------------------------------------------------------
#    Read OffsetH attribute
#------------------------------------------------------------------
    def read_OffsetH(self, attr):
        self.debug_stream("In " + self.get_name() + ".read_OffsetH()")
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.OffsetH_read) ENABLED START -----#
        try:
            self.attr_OffsetH_read = self._bunchAnalyzer.ScopeOffsetH
        except:
            self.warn_stream("In read_OffsetH() cannot get from BunchAnalyzer()")
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.OffsetH_read
        attr.set_value(self.attr_OffsetH_read)
        
#------------------------------------------------------------------
#    Read OffsetH_expert attribute
#------------------------------------------------------------------
    def read_OffsetH_expert(self, attr):
        self.debug_stream("In " + self.get_name() + ".read_OffsetH_expert()")
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.OffsetH_expert_read) ENABLED START -----#
        try:
            self.attr_OffsetH_expert_read = self._bunchAnalyzer.ScopeOffsetH
        except:
            self.warn_stream("In read_OffsetH() cannot get from BunchAnalyzer()")
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.OffsetH_expert_read
        attr.set_value(self.attr_OffsetH_expert_read)
        
#------------------------------------------------------------------
#    Write OffsetH_expert attribute
#------------------------------------------------------------------
    def write_OffsetH_expert(self, attr):
        self.debug_stream("In " + self.get_name() + ".write_OffsetH_expert()")
        data=attr.get_write_value()
        self.debug_stream("Attribute value = " + str(data))
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.OffsetH_expert_write) ENABLED START -----#
        self.attr_OffsetH_read = float(data)
        try:
            self._bunchAnalyzer.ScopeDevice.write_attribute('OffsetH',self.attr_OffsetH_read)
        except:
            self.warn_stream("In write_OffsetH() cannot set in BunchAnalyzer()")
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.OffsetH_expert_write
        
#------------------------------------------------------------------
#    Read ScaleH attribute
#------------------------------------------------------------------
    def read_ScaleH(self, attr):
        self.debug_stream("In " + self.get_name() + ".read_ScaleH()")
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.ScaleH_read) ENABLED START -----#
        try:
            self.attr_ScaleH_read = self._bunchAnalyzer.ScopeScaleH
        except:
            self.warn_stream("In read_ScaleH() cannot get from BunchAnalyzer()")
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.ScaleH_read
        attr.set_value(self.attr_ScaleH_read)
        
#------------------------------------------------------------------
#    Read ScaleH_expert attribute
#------------------------------------------------------------------
    def read_ScaleH_expert(self, attr):
        self.debug_stream("In " + self.get_name() + ".read_ScaleH_expert()")
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.ScaleH_expert_read) ENABLED START -----#
        try:
            self.attr_ScaleH_expert_read = self._bunchAnalyzer.ScopeScaleH
        except:
            self.warn_stream("In read_ScaleH() cannot get from BunchAnalyzer()")
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.ScaleH_expert_read
        attr.set_value(self.attr_ScaleH_expert_read)
        
#------------------------------------------------------------------
#    Write ScaleH_expert attribute
#------------------------------------------------------------------
    def write_ScaleH_expert(self, attr):
        self.debug_stream("In " + self.get_name() + ".write_ScaleH_expert()")
        data=attr.get_write_value()
        self.debug_stream("Attribute value = " + str(data))
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.ScaleH_expert_write) ENABLED START -----#
        self.attr_ScaleH_read = float(data)
        try:
            self._bunchAnalyzer.ScopeDevice.write_attribute('ScaleH',self.attr_ScaleH_read)
        except:
            self.warn_stream("In write_ScaleH() cannot set in BunchAnalyzer()")
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.ScaleH_expert_write
        
#------------------------------------------------------------------
#    Read SpuriousBunches attribute
#------------------------------------------------------------------
    def read_SpuriousBunches(self, attr):
        self.debug_stream("In " + self.get_name() + ".read_SpuriousBunches()")
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.SpuriousBunches_read) ENABLED START -----#
        try:
            self.attr_SpuriousBunches_read = self._bunchAnalyzer.SpuriousBunches
        except:
            self.warn_stream("In read_SpuriousBunches() cannot get from BunchAnalyzer()")
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.SpuriousBunches_read
        attr.set_value(self.attr_SpuriousBunches_read)
        
#------------------------------------------------------------------
#    Read StartingPoint attribute
#------------------------------------------------------------------
    def read_StartingPoint(self, attr):
        self.debug_stream("In " + self.get_name() + ".read_StartingPoint()")
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.StartingPoint_read) ENABLED START -----#
        try:
            self.attr_StartingPoint_read = self._bunchAnalyzer.StartingPoint
        except:
            self.warn_stream("In read_StartingPoint() cannot get from BunchAnalyzer()")
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.StartingPoint_read
        attr.set_value(self.attr_StartingPoint_read)
        
#------------------------------------------------------------------
#    Read StartingPoint_expert attribute
#------------------------------------------------------------------
    def read_StartingPoint_expert(self, attr):
        self.debug_stream("In " + self.get_name() + ".read_StartingPoint_expert()")
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.StartingPoint_expert_read) ENABLED START -----#
        try:
            self.attr_StartingPoint_expert_read = self._bunchAnalyzer.StartingPoint
        except:
            self.warn_stream("In read_StartingPoint() cannot get from BunchAnalyzer()")
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.StartingPoint_expert_read
        attr.set_value(self.attr_StartingPoint_expert_read)
        
#------------------------------------------------------------------
#    Write StartingPoint_expert attribute
#------------------------------------------------------------------
    def write_StartingPoint_expert(self, attr):
        self.debug_stream("In " + self.get_name() + ".write_StartingPoint_expert()")
        data=attr.get_write_value()
        self.debug_stream("Attribute value = " + str(data))
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.StartingPoint_expert_write) ENABLED START -----#
        if self._bunchAnalyzer != None and \
           int(data) > self._bunchAnalyzer.ScopeSampleRate:
            PyTango.Except.throw_exception("maximum reached",
                                           "This value cannot be bigger than the waveform lenght",
                                           "StartingPoint",
                                           PyTango.ErrSeverity.ERR)
        if int(data) < 0:
            PyTango.Except.throw_exception("minimum reached",
                                           "This value must be positive",
                                           "StartingPoint",
                                           PyTango.ErrSeverity.ERR)
        self.attr_StartingPoint_read = int(data)
        self.attr_StartingPoint_write = int(data)
        try:
            self._bunchAnalyzer.StartingPoint = self.attr_StartingPoint_write
        except:
            self.warn_stream("In write_StartingPoint() cannot set in BunchAnalyzer()")
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.StartingPoint_expert_write
        
#------------------------------------------------------------------
#    Read Threshold attribute
#------------------------------------------------------------------
    def read_Threshold(self, attr):
        self.debug_stream("In " + self.get_name() + ".read_Threshold()")
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.Threshold_read) ENABLED START -----#
        try:
            self.attr_Threshold_read = self._bunchAnalyzer.Threshold
        except:
            self.warn_stream("In read_Threshold() cannot get from BunchAnalyzer()")
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.Threshold_read
        attr.set_value(self.attr_Threshold_read)
        
#------------------------------------------------------------------
#    Read Threshold_expert attribute
#------------------------------------------------------------------
    def read_Threshold_expert(self, attr):
        self.debug_stream("In " + self.get_name() + ".read_Threshold_expert()")
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.Threshold_expert_read) ENABLED START -----#
        try:
            self.attr_Threshold_expert_read = self._bunchAnalyzer.Threshold
        except:
            self.warn_stream("In read_Threshold() cannot get from BunchAnalyzer()")
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.Threshold_expert_read
        attr.set_value(self.attr_Threshold_expert_read)
        
#------------------------------------------------------------------
#    Write Threshold_expert attribute
#------------------------------------------------------------------
    def write_Threshold_expert(self, attr):
        self.debug_stream("In " + self.get_name() + ".write_Threshold_expert()")
        data=attr.get_write_value()
        self.debug_stream("Attribute value = " + str(data))
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.Threshold_expert_write) ENABLED START -----#
        if float(data) > 100:
            PyTango.Except.throw_exception("maximum reached",
                                           "This value is a percentage",
                                           "Threshold",
                                           PyTango.ErrSeverity.ERR)
        if float(data) < 0:
            PyTango.Except.throw_exception("minimum reached",
                                           "This value must be positive",
                                           "Threshold",
                                           PyTango.ErrSeverity.ERR)
        self.attr_Threshold_read = float(data)
        self.attr_Threshold_write = float(data)
        try:
            self._bunchAnalyzer.Threshold = self.attr_Threshold_write
        except:
            self.warn_stream("In write_Threshold() cannot set in BunchAnalyzer()")
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.Threshold_expert_write
        
#------------------------------------------------------------------
#    Read TimingTrigger attribute
#------------------------------------------------------------------
    def read_TimingTrigger(self, attr):
        self.debug_stream("In " + self.get_name() + ".read_TimingTrigger()")
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.TimingTrigger_read) ENABLED START -----#
        try:
            self.attr_TimingTrigger_read = self._bunchAnalyzer.DelayTick
        except:
            self.warn_stream("In read_TimingTrigger() cannot get from BunchAnalyzer()")
        attr.set_value(self.attr_TimingTrigger_read)
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.TimingTrigger_read
        attr.set_value(self.attr_TimingTrigger_read)
        
#------------------------------------------------------------------
#    Read TimingTrigger_expert attribute
#------------------------------------------------------------------
    def read_TimingTrigger_expert(self, attr):
        self.debug_stream("In " + self.get_name() + ".read_TimingTrigger_expert()")
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.TimingTrigger_expert_read) ENABLED START -----#
        try:
            self.attr_TimingTrigger_read = self._bunchAnalyzer.DelayTick
        except:
            self.warn_stream("In read_TimingTrigger() cannot get from BunchAnalyzer()")
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.TimingTrigger_expert_read
        attr.set_value(self.attr_TimingTrigger_expert_read)
        
#------------------------------------------------------------------
#    Write TimingTrigger_expert attribute
#------------------------------------------------------------------
    def write_TimingTrigger_expert(self, attr):
        self.debug_stream("In " + self.get_name() + ".write_TimingTrigger_expert()")
        data=attr.get_write_value()
        self.debug_stream("Attribute value = " + str(data))
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.TimingTrigger_expert_write) ENABLED START -----#
        self.attr_TimingTrigger_read = int(data)
        try:
            self._bunchAnalyzer.DelayTick = self.attr_TimingTrigger_read
        except:
            self.warn_stream("In write_TimingTrigger() cannot set in BunchAnalyzer()")
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.TimingTrigger_expert_write
        
#------------------------------------------------------------------
#    Read emitCyclicBuffer attribute
#------------------------------------------------------------------
    def read_emitCyclicBuffer(self, attr):
        self.debug_stream("In " + self.get_name() + ".read_emitCyclicBuffer()")
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.emitCyclicBuffer_read) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.emitCyclicBuffer_read
        attr.set_value(self.attr_emitCyclicBuffer_read)
        
#------------------------------------------------------------------
#    Write emitCyclicBuffer attribute
#------------------------------------------------------------------
    def write_emitCyclicBuffer(self, attr):
        self.debug_stream("In " + self.get_name() + ".write_emitCyclicBuffer()")
        data=attr.get_write_value()
        self.debug_stream("Attribute value = " + str(data))
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.emitCyclicBuffer_write) ENABLED START -----#
        self.attr_emitCyclicBuffer_read = bool(data)
        self.set_change_event('cyclicBuffer',self.attr_emitCyclicBuffer_read,False)
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.emitCyclicBuffer_write
        
#------------------------------------------------------------------
#    Read nAcquisitions attribute
#------------------------------------------------------------------
    def read_nAcquisitions(self, attr):
        self.debug_stream("In " + self.get_name() + ".read_nAcquisitions()")
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.nAcquisitions_read) ENABLED START -----#
        try:
            self.attr_nAcquisitions_read = self._bunchAnalyzer.NAcquisitions
        except:
            self.warn_stream("In read_nAcquisitions() cannot get from BunchAnalyzer()")
        lenBuf = len(self._bunchAnalyzer.CyclicBuffer)
        if lenBuf > ALARM_SIZE_CYCLIC_BUFFER:
            attr.set_value_date_quality(lenBuf,time.time(),PyTango.AttrQuality.ATTR_ALARM)
        elif lenBuf < self.attr_nAcquisitions_read:
            attr.set_value_date_quality(lenBuf,time.time(),PyTango.AttrQuality.ATTR_CHANGING)
        else:
            attr.set_value(self.attr_nAcquisitions_read)
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.nAcquisitions_read
        #attr.set_value(self.attr_nAcquisitions_read)
        
#------------------------------------------------------------------
#    Write nAcquisitions attribute
#------------------------------------------------------------------
    def write_nAcquisitions(self, attr):
        self.debug_stream("In " + self.get_name() + ".write_nAcquisitions()")
        data=attr.get_write_value()
        self.debug_stream("Attribute value = " + str(data))
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.nAcquisitions_write) ENABLED START -----#
        if int(data) > MAX_SIZE_CYCLIC_BUFFER:
            PyTango.Except.throw_exception("maximum reached",
                                           "The maximum size of buffer is reached",
                                           "nAquisitions",
                                           PyTango.ErrSeverity.ERR)
        if int(data) < 0:
            PyTango.Except.throw_exception("minimum reached",
                                           "This value must be positive",
                                           "nAquisitions",
                                           PyTango.ErrSeverity.ERR)
        self.attr_nAcquisitions_read = int(data)
        self.attr_nAcquisitions_write = int(data)
        try:
            self._bunchAnalyzer.NAcquisitions = self.attr_nAcquisitions_write
        except:
            self.warn_stream("In write_nAcquisitions() cannot set in BunchAnalyzer()")
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.nAcquisitions_write
        
#------------------------------------------------------------------
#    Read nBunches attribute
#------------------------------------------------------------------
    def read_nBunches(self, attr):
        self.debug_stream("In " + self.get_name() + ".read_nBunches()")
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.nBunches_read) ENABLED START -----#
        try:
            self.attr_nBunches_read = self._bunchAnalyzer.FilledBunches-\
                                      self._bunchAnalyzer.SpuriousBunches
        except:
            self.warn_stream("In read_nBunches() cannot get from BunchAnalyzer()")
        if self.attr_nBunches_read < 0:
            attr.set_value(0)
        else:
            attr.set_value(self.attr_nBunches_read)
        
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.nBunches_read
        #attr.set_value(self.attr_nBunches_read)
        
#------------------------------------------------------------------
#    Read resultingFrequency attribute
#------------------------------------------------------------------
    def read_resultingFrequency(self, attr):
        self.debug_stream("In " + self.get_name() + ".read_resultingFrequency()")
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.resultingFrequency_read) ENABLED START -----#
        try:
            self.attr_resultingFrequency_read = self._bunchAnalyzer.ResultingFrequency
        except:
            self.warn_stream("In read_resultingFrequency() cannot get from BunchAnalyzer()")
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.resultingFrequency_read
        attr.set_value(self.attr_resultingFrequency_read)
        
#------------------------------------------------------------------
#    Read BunchIntensity attribute
#------------------------------------------------------------------
    def read_BunchIntensity(self, attr):
        self.debug_stream("In " + self.get_name() + ".read_BunchIntensity()")
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.BunchIntensity_read) ENABLED START -----#
        try:
            self.attr_BunchIntensity_read = self._bunchAnalyzer.BunchIntensity
        except:
            self.warn_stream("In read_BunchIntensity() cannot get from BunchAnalyzer()")
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.BunchIntensity_read
        attr.set_value(self.attr_BunchIntensity_read)
        
#------------------------------------------------------------------
#    Read CyclicBufferTrace attribute
#------------------------------------------------------------------
    def read_CyclicBufferTrace(self, attr):
        self.debug_stream("In " + self.get_name() + ".read_CyclicBufferTrace()")
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.CyclicBufferTrace_read) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.CyclicBufferTrace_read
        attr.set_value(self.attr_CyclicBufferTrace_read)
        
#------------------------------------------------------------------
#    Read cyclicBuffer attribute
#------------------------------------------------------------------
    def read_cyclicBuffer(self, attr):
        self.debug_stream("In " + self.get_name() + ".read_cyclicBuffer()")
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.cyclicBuffer_read) ENABLED START -----#
        try:
            self.attr_cyclicBuffer_read = self._bunchAnalyzer.CyclicBuffer()
        except:
            self.warn_stream("In read_cyclicBuffer() cannot get from BunchAnalyzer()")
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.cyclicBuffer_read
        attr.set_value(self.attr_cyclicBuffer_read)
        



#------------------------------------------------------------------
#    Read Attribute Hardware
#------------------------------------------------------------------
    def read_attr_hardware(self, data):
        self.debug_stream("In " + self.get_name() + ".read_attr_hardware()")
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.read_attr_hardware) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.read_attr_hardware


#==================================================================
#
#    MeasuredFillingPatternFCT command methods
#
#==================================================================

#------------------------------------------------------------------
#    Start command:
#------------------------------------------------------------------
    def Start(self):
        """ 
        
        :param : 
        :type: PyTango.DevVoid
        :return: 
        :rtype: PyTango.DevVoid """
        self.debug_stream("In " + self.get_name() +  ".Start()")
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.Start) ENABLED START -----#
        self._startCmd.set()
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.Start
        
#------------------------------------------------------------------
#    Stop command:
#------------------------------------------------------------------
    def Stop(self):
        """ 
        
        :param : 
        :type: PyTango.DevVoid
        :return: 
        :rtype: PyTango.DevVoid """
        self.debug_stream("In " + self.get_name() +  ".Stop()")
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.Stop) ENABLED START -----#
        self._stopCmd.set()
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.Stop
        
#------------------------------------------------------------------
#    Exec command:
#------------------------------------------------------------------
    def Exec(self, argin):
        """ evaluate python code inside the device server. This command can be very helpful and dangerous.
        
        :param argin: 
        :type: PyTango.DevString
        :return: 
        :rtype: PyTango.DevString """
        self.debug_stream("In " + self.get_name() +  ".Exec()")
        argout = ''
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.Exec) ENABLED START -----#
        try:
            try:
                # interpretation as expression
                argout = eval(argin,self.__globals,self.__locals)
            except SyntaxError:
                # interpretation as statement
                exec argin in self.__globals, self.__locals
                argout = self.__locals.get("y")

        except Exception, exc:
            # handles errors on both eval and exec level
            argout = traceback.format_exc()

        if type(argout)==StringType:
            return argout
        elif isinstance(argout, BaseException):
            return "%s!\n%s" % (argout.__class__.__name__, str(argout))
        else:
            try:
                return pprint.pformat(argout)
            except Exception:
                return str(argout)
        #----- PROTECTED REGION END -----#    //    MeasuredFillingPatternFCT.Exec
        return argout
        

#==================================================================
#
#    MeasuredFillingPatternFCTClass class definition
#
#==================================================================
class MeasuredFillingPatternFCTClass(PyTango.DeviceClass):

    #    Class Properties
    class_property_list = {
        }


    #    Device Properties
    device_property_list = {
        'erDev':
            [PyTango.DevString,
            "Event Receiver Device name",
            [] ],
        'FCTAttribute':
            [PyTango.DevString,
            "Channel of the scope from where the readings are get",
            [] ],
        'scoDev':
            [PyTango.DevString,
            "Scope Device name where one channel has the FCT signal",
            [] ],
        'AutoStart':
            [PyTango.DevBoolean,
            "Configure if the device must start the calculation by default when it is launched",
            [True]],
        'RfGeneratorDev':
            [PyTango.DevString,
            "RfGenerator Device name from where the frequency is read from time to time",
            [] ],
        }


    #    Command definitions
    cmd_list = {
        'Start':
            [[PyTango.DevVoid, "none"],
            [PyTango.DevVoid, "none"]],
        'Stop':
            [[PyTango.DevVoid, "none"],
            [PyTango.DevVoid, "none"]],
        'Exec':
            [[PyTango.DevString, "statement to executed"],
            [PyTango.DevString, "result"],
            {
                'Display level': PyTango.DispLevel.EXPERT,
            } ],
        }


    #    Attribute definitions
    attr_list = {
        'FilledBunches':
            [[PyTango.DevShort,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'label': "Filled Bunches",
            } ],
        'OffsetH':
            [[PyTango.DevDouble,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'label': "Oscilloscope Horizontal Offset",
                'unit': "s",
                'format': "%3.9f",
                'description': "Oscilloscope Horizontal Offset",
            } ],
        'OffsetH_expert':
            [[PyTango.DevDouble,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'label': "Oscilloscope Horizontal Offset",
                'unit': "s",
                'format': "%3.9f",
                'description': "Oscilloscope Horizontal Offset",
                'Display level': PyTango.DispLevel.EXPERT,
                'Memorized':"true"
            } ],
        'ScaleH':
            [[PyTango.DevDouble,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'label': "Oscilloscope Horizontal Scale",
                'unit': "s/div",
                'format': "%3.9f",
                'description': "Oscilloscope Horizontal Scale",
            } ],
        'ScaleH_expert':
            [[PyTango.DevDouble,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'label': "Oscilloscope Horizontal Scale",
                'unit': "s/div",
                'format': "%3.9f",
                'description': "Oscilloscope Horizontal Scale",
                'Display level': PyTango.DispLevel.EXPERT,
                'Memorized':"true"
            } ],
        'SpuriousBunches':
            [[PyTango.DevShort,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'label': "Spurious Bunches",
            } ],
        'StartingPoint':
            [[PyTango.DevShort,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'label': "Starting Point",
            } ],
        'StartingPoint_expert':
            [[PyTango.DevShort,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'label': "Starting Point",
                'Display level': PyTango.DispLevel.EXPERT,
                'Memorized':"true"
            } ],
        'Threshold':
            [[PyTango.DevDouble,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'label': "Threshold",
                'unit': "%",
                'max value': "100",
                'min value': "0",
            } ],
        'Threshold_expert':
            [[PyTango.DevDouble,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'label': "Threshold",
                'unit': "%",
                'max value': "100",
                'min value': "0",
                'Display level': PyTango.DispLevel.EXPERT,
                'Memorized':"true"
            } ],
        'TimingTrigger':
            [[PyTango.DevShort,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'label': "TimingTrigger",
                'unit': "ticks",
            } ],
        'TimingTrigger_expert':
            [[PyTango.DevShort,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'label': "Timing Trigger",
                'unit': "ticks",
                'Display level': PyTango.DispLevel.EXPERT,
                'Memorized':"true"
            } ],
        'emitCyclicBuffer':
            [[PyTango.DevBoolean,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'description': "This boolean attribute is to allow or not to emit the events on the cyclic Buffer. This is because it can cause delay dou to be too big buffer",
                'Display level': PyTango.DispLevel.EXPERT,
                'Memorized':"true"
            } ],
        'nAcquisitions':
            [[PyTango.DevUShort,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'label': "Number of acquisitions",
                'description': "Number of elements in the cyclic buffer from where the calculation takes the data.",
                'Memorized':"true"
            } ],
        'nBunches':
            [[PyTango.DevShort,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'label': "Number of Bunches",
            } ],
        'resultingFrequency':
            [[PyTango.DevDouble,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'label': "Resulting Frequency",
                'unit': "Hz",
                'format': "%3.3f",
                'description': "Expert attribute to read the frequency with this device is pushing results in the output",
                'Display level': PyTango.DispLevel.EXPERT,
            } ],
        'BunchIntensity':
            [[PyTango.DevDouble,
            PyTango.SPECTRUM,
            PyTango.READ, 5000]],
        'CyclicBufferTrace':
            [[PyTango.DevString,
            PyTango.SPECTRUM,
            PyTango.READ, 10000],
            {
                'description': "Internal use attribute to have information about how the buffer changes",
                'Display level': PyTango.DispLevel.EXPERT,
            } ],
        'cyclicBuffer':
            [[PyTango.DevDouble,
            PyTango.IMAGE,
            PyTango.READ, 40000, 50],
            {
                'description': "Expert attribute to be able to check the cyclic buffer evolution",
                'Display level': PyTango.DispLevel.EXPERT,
            } ],
        }


#------------------------------------------------------------------
#    MeasuredFillingPatternFCTClass Constructor
#------------------------------------------------------------------
    def __init__(self, name):
        PyTango.DeviceClass.__init__(self, name)
        self.set_type(name);
        print "In MeasuredFillingPatternFCT Class  constructor"

#==================================================================
#
#    MeasuredFillingPatternFCT class main method
#
#==================================================================
def main():
    try:
        py = PyTango.Util(sys.argv)
        py.add_class(MeasuredFillingPatternFCTClass,MeasuredFillingPatternFCT,'MeasuredFillingPatternFCT')

        U = PyTango.Util.instance()
        U.server_init()
        U.server_run()

    except PyTango.DevFailed,e:
        print '-------> Received a DevFailed exception:',e
    except Exception,e:
        print '-------> An unforeseen exception occured....',e

if __name__ == '__main__':
    main()
