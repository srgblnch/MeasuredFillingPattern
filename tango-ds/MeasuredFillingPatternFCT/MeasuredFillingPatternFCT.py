#!/usr/bin/env python
# -*- coding:utf-8 -*- 


##############################################################################
## license :
##============================================================================
##
## File :        MeasuredFillingPatternFCT.py
## 
## Project :     Filling Pattern from the FCT
##
## This file is part of Tango device class.
## 
## Tango is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
## 
## Tango is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
## 
## You should have received a copy of the GNU General Public License
## along with Tango.  If not, see <http://www.gnu.org/licenses/>.
## 
##
## $Author :      sblanch$
##
## $Revision :    $
##
## $Date :        $
##
## $HeadUrl :     $
##============================================================================
##            This file is generated by POGO
##    (Program Obviously used to Generate tango Object)
##
##        (c) - Software Engineering Group - ESRF
##############################################################################

"""Device to ..."""

__all__ = ["MeasuredFillingPatternFCT", "MeasuredFillingPatternFCTClass", "main"]

__docformat__ = 'restructuredtext'

import PyTango
import sys
# Add additional import
#----- PROTECTED REGION ID(MeasuredFillingPatternFCT.additionnal_import) ENABLED START -----#
import time
import threading
from BunchAnalyzer import BunchAnalyzer
import traceback

from types import StringType

META = u"""
    $URL: https://svn.code.sf.net/p/tango-ds/code/Servers/Calculation/MeasuredFillingPatternFCT $
    $LastChangedBy: sergiblanch $
    License: GPL3+
    Author: Sergi Blanch
""".encode('latin1')

#FIXME: stablish default initial values
DEFAULT_NACQUSITIONS = 30
DEFAULT_STARTINGPOINT = 0
DEFAULT_SCOPESAMPLERATE = 40.0e10
MAX_SIZE_CYCLIC_BUFFER = 100
ALARM_SIZE_CYCLIC_BUFFER = 50

DEFAULT_CYCLIC_BUFFER_TRACE = 1000

#----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.additionnal_import

## Device States Description
## ALARM : Check the status, something is not running as expected, but the calculations are still alive.
## OFF : The device is alive, but is not reading anything, neither doing any calculation
## ON : Device is doing the calculation normally
## STANDBY : The calculation have start, but not with the expected #samples in the cyclic buffer 
## FAULT : Something out of the specs, calculation stopped. Check the status.
## INIT : Just when the device is launched until its build procedure is done

class MeasuredFillingPatternFCT (PyTango.Device_4Impl):

    #--------- Add you global variables here --------------------------
    #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.global_variables) ENABLED START -----#
    def cleanAllImportantLogs(self):
        #@todo: clean the important logs when they loose importance.
        self.debug_stream("In %s::cleanAllImportantLogs()"%self.get_name())
        self._important_logs = []
        self.addStatusMsg("")

    def addStatusMsg(self,current,important = False):
        self.debug_stream("In %s::addStatusMsg()"%self.get_name())
        msg = "The device is in %s state.\n"%(self.get_state())
        for ilog in self._important_logs:
            if len(ilog) > 0:
                msg = "%s%s\n"%(msg,ilog)
        if len(current) > 0:
            status = "%s%s"%(msg,current)
        else:
            status = msg[:-1]
        self.set_status(status)
        self.push_change_event('Status',status)
        self.info_stream("Status change to %r"%(status))
        if important and not current in self._important_logs:
            self._important_logs.append(current)

    def change_state(self,newstate):
        self.info_stream("In %s::change_state(%s)"%(self.get_name(),str(newstate)))
        self.set_state(newstate)
        self.push_change_event('State',newstate)
        self.cleanAllImportantLogs()

    def createThread(self):
        self.debug_stream("In %s::createThread()"%self.get_name())
        #TODO: check if the thread can be created or if it is already created
        if not self.get_state() in [PyTango.DevState.OFF]:
            return False
        if hasattr(self,'_thread') and self._thread and self._thread.isAlive():
            self.debug_stream("In %s::createThread(): Trying to start threading when is already started."%self.get_name())
            self.change_state(PyTango.DevState.FAULT)
            self.addStatusMsg("Try to start the calculation thread when is already running.",important=True)
            return False
        self.debug_stream("In %s::createThread(): Start calculation threading."%self.get_name())
        try:
            self._joinerEvent = threading.Event()#to communicate between threads
            self._joinerEvent.clear()
            self._startCmd = threading.Event()#Start command has been received
            self._startCmd.clear()
            if self.AutoStart:
                self._startCmd.set()
            self._stopCmd = threading.Event()#Stop command has been received
            self._stopCmd.clear()
            waitThread = threading.Event()
            waitThread.clear()
            self._thread = threading.Thread(target=self.analyzerThread,args=(waitThread,))
            self._thread.setDaemon(True)
            self._thread.start()
            waitThread.wait()
            self.debug_stream("In %s::createThread(): Thread created."%self.get_name())
        except Exception,e:
            self.warn_stream("In %s::createThread(): Exception creating thread: %s."%(self.get_name(),e))
            self.change_state(PyTango.DevState.FAULT)
            self.addStatusMsg("Exception creating calculation thread.",important=True)
            return False
        return True
    def deleteThread(self):
        self.debug_stream("In %s::deleteThread(): Stoping acquisition threading."%self.get_name())
        if hasattr(self,'_joinerEvent'):
            self.debug_stream("In %s::deleteThread(): sending join event."%self.get_name())
            self._joinerEvent.set()
        if hasattr(self,'_thread'):
            self.debug_stream("In %s::deleteThread(): Thread joining."%self.get_name())
            self._thread.join(1)
            if self._thread.isAlive():
                self.debug_stream("In %s::deleteThread(): Thread joined."%self.get_name())
    
    def analyzerThread(self,waitThread):
        self.info_stream("In %s::analyzerThread(): Thread started."%self.get_name())
        if not hasattr(self,'_joinerEvent'):
            raise Exception("Not possible to start the loop because it have not end condition")
#        self.change_state(PyTango.DevState.STANDBY)#FIXME: change the state when it starts to work
#        self.cleanAllImportantLogs()
#        self.addStatusMsg("Starting buffer population")
        #Build the analyzer object
        try:
            time.sleep(1)
            self.debug_stream("Build BunchAnalyser instance")
            self._bunchAnalyzer = BunchAnalyzer(parent=self,
                                timingDevName=self.erDev,
                                delayTick=self.attr_TimingTrigger_read,
                                scopeDevName=self.scoDev,
                                cyclicBuffer=self.attr_cyclicBuffer_read,
                                rfDev=self.RfGeneratorDev,
                                rfAttr=self.RfGeneratorAttr,
                                dcctDev=self.dcctDev,
                                dcctAttr=self.dcctAttr,
                                threshold=self.attr_Threshold_write,
                                nAcquisitions=self.attr_nAcquisitions_write,
                                startingPoint=self.attr_StartingPoint_write,
                                max_cyclicBuf=MAX_SIZE_CYCLIC_BUFFER,
                                alarm_cyclicBuf=ALARM_SIZE_CYCLIC_BUFFER)
            self.debug_stream("Build BunchAnalyser made")
            self.attr_TimingTrigger_read = self._bunchAnalyzer.DelayTick
            waitThread.set()
        except:
            self.change_state(PyTango.DevState.FAULT)
            self.addStatusMsg("Cannot build the analyzer",important=True)
            waitThread.set()
            return
#        try:
#            self.readRfAttributes()
#        except:
#            self.debug_stream("Exception reading RF attrs")
#        self.readScopeAttributes()
        while not self._joinerEvent.isSet():
            #TODO: passive wait until no new data is available
            #FIXME: can this start with less samples in the buffer than the 
            #       number configured in the nAcquisitions attribute?
            #TODO: if a loop takes too long ALARM state and a message
            try:
                if self._startCmd.isSet():
                    self._startCmd.clear()
                    if not self.get_state() in [PyTango.DevState.STANDBY,
                                                PyTango.DevState.ON]:
                        try:
                            # Subscribe to events of the scope channel
                            self._bunchAnalyzer.CyclicBuffer = []
                            self._bunchAnalyzer.subscribe_event(self.FCTAttribute)
                        except Exception,e:
                            self.change_state(PyTango.DevState.FAULT)
                            self.addStatusMsg("Cannot subscribe to the FCT",important=True)
                            self.debug_stream("Cannot subscribe to the FCT due to: %s"%(e))
                if self._stopCmd.isSet():
                    self._stopCmd.clear()
                    if not self.get_state() in [PyTango.DevState.OFF]:
                        try:
                            self._bunchAnalyzer.unsubscribe_event()
                            eventList = []
                            eventList.append(['nAcquisitions',0])#,PyTango.AttrQuality.ATTR_INVALID])
                            eventList.append(['CyclicBuffer',[[0]]])#,PyTango.AttrQuality.ATTR_INVALID])
                            eventList.append(['BunchIntensity',[0]])#,PyTango.AttrQuality.ATTR_INVALID])
                            eventList.append(['FilledBunches',0])#,PyTango.AttrQuality.ATTR_INVALID])
                            eventList.append(['SpuriousBunches',0])#,PyTango.AttrQuality.ATTR_INVALID])
                            eventList.append(['nBunches',0])#,PyTango.AttrQuality.ATTR_INVALID])
                            eventList.append(['resultingFrequency',0])#,PyTango.AttrQuality.ATTR_INVALID])
                            self.fireEventsList(eventList)
                        except Exception,e:
                            self.change_state(PyTango.DevState.FAULT)
                            self.addStatusMsg("Cannot unsubscribe to the FCT",
                                              important=True)
                            self.debug_stream("Cannot unsubscribe to the FCT "\
                                              "due to: %s"%(e))
                time.sleep(1)
                #secundary attributes to read periodically and without events
#                self.readRfAttributes()
#                self.readScopeAttributes()
            except Exception,e:
                self.error_stream("In %s::analyzerThread(): Exception: %s"
                                  %(self.get_name(),e))
            
    def fireEventsList(self,eventsAttrList):
        #self.debug_stream("In %s::fireEventsList()"%self.get_name())
        #@todo: add the value on the push_event
        timestamp = time.time()
        for attrEvent in eventsAttrList:
            try:
                self.debug_stream("In %s::fireEventsList() attribute: %s"
                                  %(self.get_name(),attrEvent[0]))
                if attrEvent[0] in ['CyclicBuffer'] and \
                not self.attr_emitCyclicBuffer_read:
                    self.debug_stream("In %s::fireEventsList() attribute: %s "\
                                      "avoided to emit the event duo to flag."
                                      %(self.get_name(),attrEvent[0]))
                elif len(attrEvent) == 3:#specifies quality
                    self.push_change_event(attrEvent[0],attrEvent[1],timestamp,
                                           attrEvent[2])
                else:
                    self.push_change_event(attrEvent[0],attrEvent[1],timestamp,
                                           PyTango.AttrQuality.ATTR_VALID)
            except Exception,e:
                self.error_stream("In %s::fireEventsList() Exception with "\
                                  "attribute %s: %s"
                                  %(self.get_name(),attrEvent[0],e))
                traceback.print_exc()

#    def readRfAttributes(self):
#        #if more than one, use read attributes
#        if self._bunchAnalyzer != None:
#            self._bunchAnalyzer.RfFrequency(PyTango.AttributeProxy(\
#                               self.RfGeneratorDev+'/Frequency').read().value)

#    def readScopeAttributes(self):
#        if self._bunchAnalyzer != None:
#            try:
#                device = self._bunchAnalyzer.ScopeDevice()
#                attrs = device.read_attributes(['CurrentSampleRate',
#                                                'ScaleH',
#                                                'OffsetH'])
#                self.debug_stream("SampleRate = %f"%attrs[0].value)
#                self._bunchAnalyzer.ScopeSampleRate(attrs[0].value)
#                self.scopeSampleRate = self._bunchAnalyzer.ScopeSampleRate()
#                self.attr_ScaleH_read = attrs[1].value
#                self.attr_OffsetH_read = attrs[2].value
#            except Exception,e:
#                self.debug_stream("Exception reading Scope attrs: %s"%e)

    def _cyclicBufferTracer(self,msg):
        now = time.strftime("%Y%m%d_%H%M%S")
        self.attr_CyclicBufferTrace_read.append("%s: %s"%(now,msg))
        #clean too old messages
        if len(self.attr_CyclicBufferTrace_read) > DEFAULT_CYCLIC_BUFFER_TRACE:
            self.attr_CyclicBufferTrace_read = self.attr_CyclicBufferTrace_read[-DEFAULT_CYCLIC_BUFFER_TRACE]

    #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.global_variables

    def __init__(self,cl, name):
        PyTango.Device_4Impl.__init__(self,cl,name)
        self.debug_stream("In __init__()")
        MeasuredFillingPatternFCT.init_device(self)
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.__init__) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.__init__
        
    def delete_device(self):
        self.debug_stream("In delete_device()")
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.delete_device) ENABLED START -----#
        self.deleteThread()
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.delete_device

    def init_device(self):
        self.debug_stream("In init_device()")
        self.get_device_properties(self.get_device_class())
        self.attr_FilledBunches_read = 0
        self.attr_OffsetH_read = 0.0
        self.attr_OffsetH_expert_read = 0.0
        self.attr_ScaleH_read = 0.0
        self.attr_ScaleH_expert_read = 0.0
        self.attr_SpuriousBunches_read = 0
        self.attr_StartingPoint_read = 0
        self.attr_StartingPoint_expert_read = 0
        self.attr_Threshold_read = 0.0
        self.attr_Threshold_expert_read = 0.0
        self.attr_TimingTrigger_read = 0
        self.attr_TimingTrigger_expert_read = 0
        self.attr_emitCyclicBuffer_read = False
        self.attr_nAcquisitions_read = 0
        self.attr_nBunches_read = 0
        self.attr_resultingFrequency_read = 0.0
        self.attr_CurrentSampleRate_read = 0.0
        self.attr_BunchIntensity_read = [0.0]
        self.attr_CyclicBufferTrace_read = ['']
        self.attr_InputSignal_read = [0.0]
        self.attr_cyclicBuffer_read = [[0.0]]
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.init_device) ENABLED START -----#
        self.attr_nAcquisitions_write = DEFAULT_NACQUSITIONS
        self.attr_StartingPoint_write = DEFAULT_STARTINGPOINT
        self.attr_Threshold_write = 0.0
        self.CurrentSampleRate = DEFAULT_SCOPESAMPLERATE
        self._bunchAnalyzer = None
        self._important_logs = []
        #tools for the Exec() cmd
        DS_MODULE = __import__(self.__class__.__module__)
        kM = dir(DS_MODULE)
        vM = map(DS_MODULE.__getattribute__, kM)
        self.__globals = dict(zip(kM, vM))
        self.__globals['self'] = self
        self.__globals['module'] = DS_MODULE
        self.__locals = {}
        #prepare attributes that will have events
        self.set_change_event('State', True, False)
        self.set_change_event('Status', True, False)
        #self.set_change_event('cyclicBuffer',True,False)
        self.set_change_event('nAcquisitions',True,False)
        self.set_change_event('BunchIntensity',True,False)
        self.set_change_event('FilledBunches',True,False)
        self.set_change_event('SpuriousBunches',True,False)
        self.set_change_event('nBunches',True,False)
        self.set_change_event('resultingFrequency',True,False)
        self.set_change_event('InputSignal', True, False)
        self.change_state(PyTango.DevState.OFF)
        #prepare the analyzer thread
        if self.createThread():
            self.addStatusMsg("Analyzer thread well created")
        else:
            self.change_state(PyTango.DevState.FAULT)
            self.cleanAllImportantLogs()
            self.addStatusMsg("Analyzer thread cannot be created")
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.init_device

    def always_executed_hook(self):
        self.debug_stream("In always_excuted_hook()")
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.always_executed_hook) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.always_executed_hook

    #-----------------------------------------------------------------------------
    #    MeasuredFillingPatternFCT read/write attribute methods
    #-----------------------------------------------------------------------------
    
    def read_FilledBunches(self, attr):
        self.debug_stream("In read_FilledBunches()")
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.FilledBunches_read) ENABLED START -----#
        try:
            self.attr_FilledBunches_read = self._bunchAnalyzer.FilledBunches
        except:
            self.warn_stream("In read_FilledBunches() cannot get from BunchAnalyzer()")
        attr.set_value(self.attr_FilledBunches_read)
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.FilledBunches_read
        
    def is_FilledBunches_allowed(self, attr):
        self.debug_stream("In is_FilledBunches_allowed()")
        if attr==PyTango.AttReqType.READ_REQ:
            state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
                PyTango.DevState.INIT])
        else:
            state_ok = not(self.get_state() in [])
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.is_FilledBunches_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.is_FilledBunches_allowed
        return state_ok
        
    def read_OffsetH(self, attr):
        self.debug_stream("In read_OffsetH()")
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.OffsetH_read) ENABLED START -----#
        try:
            self.attr_OffsetH_read = self._bunchAnalyzer.ScopeOffsetH
        except:
            self.warn_stream("In read_OffsetH() cannot get from BunchAnalyzer()")
        attr.set_value(self.attr_OffsetH_read)
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.OffsetH_read
        
    def is_OffsetH_allowed(self, attr):
        self.debug_stream("In is_OffsetH_allowed()")
        if attr==PyTango.AttReqType.READ_REQ:
            state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
                PyTango.DevState.INIT])
        else:
            state_ok = not(self.get_state() in [])
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.is_OffsetH_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.is_OffsetH_allowed
        return state_ok
        
    def read_OffsetH_expert(self, attr):
        self.debug_stream("In read_OffsetH_expert()")
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.OffsetH_expert_read) ENABLED START -----#
        try:
            self.attr_OffsetH_expert_read = self._bunchAnalyzer.ScopeOffsetH
        except:
            self.warn_stream("In read_OffsetH() cannot get from BunchAnalyzer()")
        attr.set_value(self.attr_OffsetH_expert_read)
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.OffsetH_expert_read
        
    def write_OffsetH_expert(self, attr):
        self.debug_stream("In write_OffsetH_expert()")
        data=attr.get_write_value()
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.OffsetH_expert_write) ENABLED START -----#
        self.attr_OffsetH_expert_read = float(data)
        try:
            self._bunchAnalyzer.ScopeOffsetH = self.attr_OffsetH_expert_read
            self.attr_OffsetH_read = self._bunchAnalyzer.ScopeOffsetH
        except:
            self.warn_stream("In write_OffsetH() cannot set in BunchAnalyzer()")
        self.fireEventsList([['OffsetH',self.attr_OffsetH_read]])
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.OffsetH_expert_write
        
    def is_OffsetH_expert_allowed(self, attr):
        self.debug_stream("In is_OffsetH_expert_allowed()")
        if attr==PyTango.AttReqType.READ_REQ:
            state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
                PyTango.DevState.INIT])
        else:
            state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
                PyTango.DevState.INIT])
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.is_OffsetH_expert_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.is_OffsetH_expert_allowed
        return state_ok
        
    def read_ScaleH(self, attr):
        self.debug_stream("In read_ScaleH()")
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.ScaleH_read) ENABLED START -----#
        try:
            self.debug_stream("self._bunchAnalyzer = %s"%(self._bunchAnalyzer))
            self.attr_ScaleH_read = self._bunchAnalyzer.ScopeScaleH
        except:
            self.warn_stream("In read_ScaleH() cannot get from BunchAnalyzer()")
        attr.set_value(self.attr_ScaleH_read)
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.ScaleH_read
        
    def is_ScaleH_allowed(self, attr):
        self.debug_stream("In is_ScaleH_allowed()")
        if attr==PyTango.AttReqType.READ_REQ:
            state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
                PyTango.DevState.INIT])
        else:
            state_ok = not(self.get_state() in [])
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.is_ScaleH_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.is_ScaleH_allowed
        return state_ok
        
    def read_ScaleH_expert(self, attr):
        self.debug_stream("In read_ScaleH_expert()")
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.ScaleH_expert_read) ENABLED START -----#
        try:
            self.attr_ScaleH_expert_read = self._bunchAnalyzer.ScopeScaleH
        except:
            self.warn_stream("In read_ScaleH() cannot get from BunchAnalyzer()")
        attr.set_value(self.attr_ScaleH_expert_read)
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.ScaleH_expert_read
        
    def write_ScaleH_expert(self, attr):
        self.debug_stream("In write_ScaleH_expert()")
        data=attr.get_write_value()
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.ScaleH_expert_write) ENABLED START -----#
        self.attr_ScaleH_expert_read = float(data)
        try:
            self._bunchAnalyzer.ScopeScaleH = self.attr_ScaleH_expert_read
            self.attr_ScaleH_read = self._bunchAnalyzer.ScopeScaleH
        except Exception,e:
            self.warn_stream("In write_ScaleH() cannot set in BunchAnalyzer(): %s"%e)
            traceback.print_exc()
#        except:
#            self.warn_stream("In write_ScaleH() cannot set in BunchAnalyzer()")
        self.fireEventsList([['ScaleH',self.attr_ScaleH_read]])
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.ScaleH_expert_write
        
    def is_ScaleH_expert_allowed(self, attr):
        self.debug_stream("In is_ScaleH_expert_allowed()")
        if attr==PyTango.AttReqType.READ_REQ:
            state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
                PyTango.DevState.INIT])
        else:
            state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
                PyTango.DevState.INIT])
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.is_ScaleH_expert_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.is_ScaleH_expert_allowed
        return state_ok
        
    def read_SpuriousBunches(self, attr):
        self.debug_stream("In read_SpuriousBunches()")
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.SpuriousBunches_read) ENABLED START -----#
        try:
            self.attr_SpuriousBunches_read = self._bunchAnalyzer.SpuriousBunches
        except:
            self.warn_stream("In read_SpuriousBunches() cannot get from BunchAnalyzer()")
        attr.set_value(self.attr_SpuriousBunches_read)
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.SpuriousBunches_read
        
    def is_SpuriousBunches_allowed(self, attr):
        self.debug_stream("In is_SpuriousBunches_allowed()")
        if attr==PyTango.AttReqType.READ_REQ:
            state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
                PyTango.DevState.INIT])
        else:
            state_ok = not(self.get_state() in [])
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.is_SpuriousBunches_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.is_SpuriousBunches_allowed
        return state_ok
        
    def read_StartingPoint(self, attr):
        self.debug_stream("In read_StartingPoint()")
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.StartingPoint_read) ENABLED START -----#
        try:
            self.attr_StartingPoint_read = self._bunchAnalyzer.StartingPoint
        except:
            self.warn_stream("In read_StartingPoint() cannot get from BunchAnalyzer()")
        attr.set_value(self.attr_StartingPoint_read)
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.StartingPoint_read
        
    def is_StartingPoint_allowed(self, attr):
        self.debug_stream("In is_StartingPoint_allowed()")
        if attr==PyTango.AttReqType.READ_REQ:
            state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
                PyTango.DevState.INIT])
        else:
            state_ok = not(self.get_state() in [])
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.is_StartingPoint_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.is_StartingPoint_allowed
        return state_ok
        
    def read_StartingPoint_expert(self, attr):
        self.debug_stream("In read_StartingPoint_expert()")
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.StartingPoint_expert_read) ENABLED START -----#
        try:
            self.attr_StartingPoint_expert_read = self._bunchAnalyzer.StartingPoint
        except:
            self.warn_stream("In read_StartingPoint() cannot get from BunchAnalyzer()")
        attr.set_value(self.attr_StartingPoint_expert_read)
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.StartingPoint_expert_read
        
    def write_StartingPoint_expert(self, attr):
        self.debug_stream("In write_StartingPoint_expert()")
        data=attr.get_write_value()
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.StartingPoint_expert_write) ENABLED START -----#
        if self._bunchAnalyzer != None and \
           int(data) > self._bunchAnalyzer.ScopeSampleRate:
            PyTango.Except.throw_exception("maximum reached",
                                           "This value cannot be bigger than "\
                                           "the waveform lenght",
                                           "StartingPoint",
                                           PyTango.ErrSeverity.ERR)
        if int(data) < 0:
            PyTango.Except.throw_exception("minimum reached",
                                           "This value must be positive",
                                           "StartingPoint",
                                           PyTango.ErrSeverity.ERR)
        self.attr_StartingPoint_expert_read = int(data)
        self.attr_StartingPoint_write = self.attr_StartingPoint_expert_read
        try:
            self._bunchAnalyzer.StartingPoint = self.attr_StartingPoint_write
            self.attr_StartingPoint_read = self._bunchAnalyzer.StartingPoint
        except:
            self.warn_stream("In write_StartingPoint() cannot set in BunchAnalyzer()")
        self.fireEventsList([['StartingPoint',self.attr_StartingPoint_read]])
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.StartingPoint_expert_write
        
    def is_StartingPoint_expert_allowed(self, attr):
        self.debug_stream("In is_StartingPoint_expert_allowed()")
        if attr==PyTango.AttReqType.READ_REQ:
            state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
                PyTango.DevState.INIT])
        else:
            state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
                PyTango.DevState.INIT])
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.is_StartingPoint_expert_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.is_StartingPoint_expert_allowed
        return state_ok
        
    def read_Threshold(self, attr):
        self.debug_stream("In read_Threshold()")
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.Threshold_read) ENABLED START -----#
        try:
            self.attr_Threshold_read = self._bunchAnalyzer.Threshold
        except:
            self.warn_stream("In read_Threshold() cannot get from BunchAnalyzer()")
        attr.set_value(self.attr_StartingPoint_read)
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.Threshold_read
        
    def is_Threshold_allowed(self, attr):
        self.debug_stream("In is_Threshold_allowed()")
        if attr==PyTango.AttReqType.READ_REQ:
            state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
                PyTango.DevState.INIT])
        else:
            state_ok = not(self.get_state() in [])
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.is_Threshold_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.is_Threshold_allowed
        return state_ok
        
    def read_Threshold_expert(self, attr):
        self.debug_stream("In read_Threshold_expert()")
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.Threshold_expert_read) ENABLED START -----#
        try:
            self.attr_Threshold_expert_read = self._bunchAnalyzer.Threshold
        except:
            self.warn_stream("In read_Threshold() cannot get from BunchAnalyzer()")
        attr.set_value(self.attr_Threshold_expert_read)
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.Threshold_expert_read
        
    def write_Threshold_expert(self, attr):
        self.debug_stream("In write_Threshold_expert()")
        data=attr.get_write_value()
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.Threshold_expert_write) ENABLED START -----#
        if float(data) > 100:
            PyTango.Except.throw_exception("maximum reached",
                                           "This value is a percentage",
                                           "Threshold",
                                           PyTango.ErrSeverity.ERR)
        if float(data) < 0:
            PyTango.Except.throw_exception("minimum reached",
                                           "This value must be positive",
                                           "Threshold",
                                           PyTango.ErrSeverity.ERR)
        self.attr_Threshold_expert_read = float(data)
        self.attr_Threshold_write = self.attr_Threshold_expert_read
        try:
            self._bunchAnalyzer.Threshold = self.attr_Threshold_write
            self.attr_Threshold_read = self._bunchAnalyzer.Threshold
        except:
            self.warn_stream("In write_Threshold() cannot set in BunchAnalyzer()")
        self.fireEventsList([['Threshold',self.attr_Threshold_read]])
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.Threshold_expert_write
        
    def is_Threshold_expert_allowed(self, attr):
        self.debug_stream("In is_Threshold_expert_allowed()")
        if attr==PyTango.AttReqType.READ_REQ:
            state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
                PyTango.DevState.INIT])
        else:
            state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
                PyTango.DevState.INIT])
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.is_Threshold_expert_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.is_Threshold_expert_allowed
        return state_ok
        
    def read_TimingTrigger(self, attr):
        self.debug_stream("In read_TimingTrigger()")
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.TimingTrigger_read) ENABLED START -----#
        try:
            self.attr_TimingTrigger_read = self._bunchAnalyzer.DelayTick
        except:
            self.warn_stream("In read_TimingTrigger() cannot get from BunchAnalyzer()")
        attr.set_value(self.attr_TimingTrigger_read)
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.TimingTrigger_read
        
    def is_TimingTrigger_allowed(self, attr):
        self.debug_stream("In is_TimingTrigger_allowed()")
        if attr==PyTango.AttReqType.READ_REQ:
            state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
                PyTango.DevState.INIT])
        else:
            state_ok = not(self.get_state() in [])
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.is_TimingTrigger_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.is_TimingTrigger_allowed
        return state_ok
        
    def read_TimingTrigger_expert(self, attr):
        self.debug_stream("In read_TimingTrigger_expert()")
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.TimingTrigger_expert_read) ENABLED START -----#
        try:
            self.attr_TimingTrigger_export_read = self._bunchAnalyzer.DelayTick
        except:
            self.warn_stream("In read_TimingTrigger() cannot get from BunchAnalyzer()")
        attr.set_value(self.attr_TimingTrigger_read)
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.TimingTrigger_expert_read
        
    def write_TimingTrigger_expert(self, attr):
        self.debug_stream("In write_TimingTrigger_expert()")
        data=attr.get_write_value()
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.TimingTrigger_expert_write) ENABLED START -----#
        self.attr_TimingTrigger_expert_read = int(data)
        self.attr_Threshold_write = self.attr_TimingTrigger_expert_read
        try:
            self._bunchAnalyzer.DelayTick = self.attr_Threshold_write
            self.attr_TimingTrigger_read = self._bunchAnalyzer.DelayTick
        except:
            self.warn_stream("In write_TimingTrigger() cannot set in BunchAnalyzer()")
        self.fireEventsList([['TimingTrigger',self.attr_TimingTrigger_read]])
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.TimingTrigger_expert_write
        
    def is_TimingTrigger_expert_allowed(self, attr):
        self.debug_stream("In is_TimingTrigger_expert_allowed()")
        if attr==PyTango.AttReqType.READ_REQ:
            state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
                PyTango.DevState.INIT])
        else:
            state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
                PyTango.DevState.INIT])
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.is_TimingTrigger_expert_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.is_TimingTrigger_expert_allowed
        return state_ok
        
    def read_emitCyclicBuffer(self, attr):
        self.debug_stream("In read_emitCyclicBuffer()")
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.emitCyclicBuffer_read) ENABLED START -----#
        attr.set_value(self.attr_emitCyclicBuffer_read)
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.emitCyclicBuffer_read
        
    def write_emitCyclicBuffer(self, attr):
        self.debug_stream("In write_emitCyclicBuffer()")
        data=attr.get_write_value()
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.emitCyclicBuffer_write) ENABLED START -----#
        self.attr_emitCyclicBuffer_read = bool(data)
        self.set_change_event('cyclicBuffer',self.attr_emitCyclicBuffer_read,False)
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.emitCyclicBuffer_write
        
    def is_emitCyclicBuffer_allowed(self, attr):
        self.debug_stream("In is_emitCyclicBuffer_allowed()")
        if attr==PyTango.AttReqType.READ_REQ:
            state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
                PyTango.DevState.INIT])
        else:
            state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
                PyTango.DevState.INIT])
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.is_emitCyclicBuffer_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.is_emitCyclicBuffer_allowed
        return state_ok
        
    def read_nAcquisitions(self, attr):
        self.debug_stream("In read_nAcquisitions()")
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.nAcquisitions_read) ENABLED START -----#
        try:
            self.attr_nAcquisitions_read = self._bunchAnalyzer.NAcquisitions
        except:
            self.warn_stream("In read_nAcquisitions() cannot get from BunchAnalyzer()")
        lenBuf = len(self._bunchAnalyzer.CyclicBuffer)
        if lenBuf > ALARM_SIZE_CYCLIC_BUFFER:
            attr.set_value_date_quality(lenBuf,time.time(),PyTango.AttrQuality.ATTR_ALARM)
        elif lenBuf < self.attr_nAcquisitions_read:
            attr.set_value_date_quality(lenBuf,time.time(),PyTango.AttrQuality.ATTR_CHANGING)
        else:
            attr.set_value(self.attr_nAcquisitions_read)
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.nAcquisitions_read
        
    def write_nAcquisitions(self, attr):
        self.debug_stream("In write_nAcquisitions()")
        data=attr.get_write_value()
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.nAcquisitions_write) ENABLED START -----#
        if int(data) > MAX_SIZE_CYCLIC_BUFFER:
            PyTango.Except.throw_exception("maximum reached",
                                           "The maximum size of buffer is reached",
                                           "nAquisitions",
                                           PyTango.ErrSeverity.ERR)
        if int(data) < 0:
            PyTango.Except.throw_exception("minimum reached",
                                           "This value must be positive",
                                           "nAquisitions",
                                           PyTango.ErrSeverity.ERR)
        self.attr_nAcquisitions_read = int(data)
        self.attr_nAcquisitions_write = self.attr_nAcquisitions_read
        try:
            self._bunchAnalyzer.NAcquisitions = self.attr_nAcquisitions_write
            self.attr_nAcquisitions_read = self._bunchAnalyzer.NAcquisitions
        except:
            self.warn_stream("In write_nAcquisitions() cannot set in BunchAnalyzer()")
        self.fireEventsList([['nAcquisitions',self.attr_nAcquisitions_read]])
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.nAcquisitions_write
        
    def is_nAcquisitions_allowed(self, attr):
        self.debug_stream("In is_nAcquisitions_allowed()")
        if attr==PyTango.AttReqType.READ_REQ:
            state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
                PyTango.DevState.INIT])
        else:
            state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
                PyTango.DevState.INIT])
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.is_nAcquisitions_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.is_nAcquisitions_allowed
        return state_ok
        
    def read_nBunches(self, attr):
        self.debug_stream("In read_nBunches()")
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.nBunches_read) ENABLED START -----#
        try:
            self.attr_nBunches_read = self._bunchAnalyzer.FilledBunches-\
                                      self._bunchAnalyzer.SpuriousBunches
        except:
            self.warn_stream("In read_nBunches() cannot get from BunchAnalyzer()")
        if self.attr_nBunches_read < 0:
            attr.set_value(0)
        else:
            attr.set_value(self.attr_nBunches_read)
        
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.nBunches_read
        
    def is_nBunches_allowed(self, attr):
        self.debug_stream("In is_nBunches_allowed()")
        if attr==PyTango.AttReqType.READ_REQ:
            state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
                PyTango.DevState.INIT])
        else:
            state_ok = not(self.get_state() in [])
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.is_nBunches_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.is_nBunches_allowed
        return state_ok
        
    def read_resultingFrequency(self, attr):
        self.debug_stream("In read_resultingFrequency()")
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.resultingFrequency_read) ENABLED START -----#
        try:
            self.attr_resultingFrequency_read = self._bunchAnalyzer.ResultingFrequency
        except:
            self.warn_stream("In read_resultingFrequency() cannot get from BunchAnalyzer()")
        attr.set_value(self.attr_resultingFrequency_read)
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.resultingFrequency_read
        
    def is_resultingFrequency_allowed(self, attr):
        self.debug_stream("In is_resultingFrequency_allowed()")
        if attr==PyTango.AttReqType.READ_REQ:
            state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
                PyTango.DevState.INIT])
        else:
            state_ok = not(self.get_state() in [])
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.is_resultingFrequency_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.is_resultingFrequency_allowed
        return state_ok
        
    def read_CurrentSampleRate(self, attr):
        self.debug_stream("In read_CurrentSampleRate()")
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.CurrentSampleRate_read) ENABLED START -----#
        try:
            self.attr_CurrentSampleRate_read = self._bunchAnalyzer.ScopeSampleRate
        except:
            self.warn_stream("In read_CurrentSampleRate() cannot get from BunchAnalyzer()")
        attr.set_value(self.attr_CurrentSampleRate_read)
        
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.CurrentSampleRate_read
        
    def is_CurrentSampleRate_allowed(self, attr):
        self.debug_stream("In is_CurrentSampleRate_allowed()")
        if attr==PyTango.AttReqType.READ_REQ:
            state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
                PyTango.DevState.INIT])
        else:
            state_ok = not(self.get_state() in [])
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.is_CurrentSampleRate_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.is_CurrentSampleRate_allowed
        return state_ok
        
    def read_BunchIntensity(self, attr):
        self.debug_stream("In read_BunchIntensity()")
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.BunchIntensity_read) ENABLED START -----#
        try:
            self.attr_BunchIntensity_read = self._bunchAnalyzer.BunchIntensity
        except:
            self.warn_stream("In read_BunchIntensity() cannot get from BunchAnalyzer()")
        attr.set_value(self.attr_BunchIntensity_read)
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.BunchIntensity_read
        
    def is_BunchIntensity_allowed(self, attr):
        self.debug_stream("In is_BunchIntensity_allowed()")
        if attr==PyTango.AttReqType.READ_REQ:
            state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
                PyTango.DevState.INIT])
        else:
            state_ok = not(self.get_state() in [])
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.is_BunchIntensity_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.is_BunchIntensity_allowed
        return state_ok
        
    def read_CyclicBufferTrace(self, attr):
        self.debug_stream("In read_CyclicBufferTrace()")
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.CyclicBufferTrace_read) ENABLED START -----#
        self.set_value(self.attr_CyclicBufferTrace_read)
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.CyclicBufferTrace_read
        
    def is_CyclicBufferTrace_allowed(self, attr):
        self.debug_stream("In is_CyclicBufferTrace_allowed()")
        if attr==PyTango.AttReqType.READ_REQ:
            state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
                PyTango.DevState.INIT])
        else:
            state_ok = not(self.get_state() in [])
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.is_CyclicBufferTrace_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.is_CyclicBufferTrace_allowed
        return state_ok
        
    def read_InputSignal(self, attr):
        self.debug_stream("In read_InputSignal()")
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.InputSignal_read) ENABLED START -----#
        try:
            self.attr_InputSignal_read = self._bunchAnalyzer.InputSignal
        except:
            self.warn_stream("In read_BunchIntensity() cannot get from BunchAnalyzer()")
        attr.set_value(self.attr_InputSignal_read)
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.InputSignal_read
        
    def is_InputSignal_allowed(self, attr):
        self.debug_stream("In is_InputSignal_allowed()")
        if attr==PyTango.AttReqType.READ_REQ:
            state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
                PyTango.DevState.INIT])
        else:
            state_ok = not(self.get_state() in [])
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.is_InputSignal_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.is_InputSignal_allowed
        return state_ok
        
    def read_cyclicBuffer(self, attr):
        self.debug_stream("In read_cyclicBuffer()")
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.cyclicBuffer_read) ENABLED START -----#
        try:
            self.attr_cyclicBuffer_read = self._bunchAnalyzer.CyclicBuffer
        except:
            self.warn_stream("In read_cyclicBuffer() cannot get from BunchAnalyzer()")
        attr.set_value(self.attr_cyclicBuffer_read)
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.cyclicBuffer_read
        
    def is_cyclicBuffer_allowed(self, attr):
        self.debug_stream("In is_cyclicBuffer_allowed()")
        if attr==PyTango.AttReqType.READ_REQ:
            state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
                PyTango.DevState.INIT])
        else:
            state_ok = not(self.get_state() in [])
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.is_cyclicBuffer_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.is_cyclicBuffer_allowed
        return state_ok
        
    
    
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.initialize_dynamic_attributes) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.initialize_dynamic_attributes
            
    def read_attr_hardware(self, data):
        self.debug_stream("In read_attr_hardware()")
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.read_attr_hardware) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.read_attr_hardware


    #-----------------------------------------------------------------------------
    #    MeasuredFillingPatternFCT command methods
    #-----------------------------------------------------------------------------
    
    def Start(self):
        """ 
        
        :param : 
        :type: PyTango.DevVoid
        :return: 
        :rtype: PyTango.DevVoid """
        self.debug_stream("In Start()")
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.Start) ENABLED START -----#
        self._startCmd.set()
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.Start
        
    def is_Start_allowed(self):
        self.debug_stream("In is_Start_allowed()")
        state_ok = not(self.get_state() in [PyTango.DevState.ON,
            PyTango.DevState.FAULT,
            PyTango.DevState.INIT])
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.is_Start_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.is_Start_allowed
        return state_ok
        
    def Stop(self):
        """ 
        
        :param : 
        :type: PyTango.DevVoid
        :return: 
        :rtype: PyTango.DevVoid """
        self.debug_stream("In Stop()")
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.Stop) ENABLED START -----#
        self._stopCmd.set()
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.Stop
        
    def is_Stop_allowed(self):
        self.debug_stream("In is_Stop_allowed()")
        state_ok = not(self.get_state() in [PyTango.DevState.OFF,
            PyTango.DevState.FAULT,
            PyTango.DevState.INIT])
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.is_Stop_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.is_Stop_allowed
        return state_ok
        
    def Exec(self, argin):
        """ 
        
        :param argin: statement to executed
        :type: PyTango.DevString
        :return: result
        :rtype: PyTango.DevString """
        self.debug_stream("In Exec()")
        argout = ''
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.Exec) ENABLED START -----#
        try:
            try:
                # interpretation as expression
                argout = eval(argin,self.__globals,self.__locals)
            except SyntaxError:
                # interpretation as statement
                exec argin in self.__globals, self.__locals
                argout = self.__locals.get("y")

        except Exception, exc:
            # handles errors on both eval and exec level
            argout = traceback.format_exc()

        if type(argout)==StringType:
            return argout
        elif isinstance(argout, BaseException):
            return "%s!\n%s" % (argout.__class__.__name__, str(argout))
        else:
            try:
                return pprint.pformat(argout)
            except Exception:
                return str(argout)
        #----- PROTECTED REGION END -----#    //    MeasuredFillingPatternFCT.Exec
        return argout
        

    #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.programmer_methods) ENABLED START -----#
    def initialize_dynamic_attributes(self):
        pass
    #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.programmer_methods

class MeasuredFillingPatternFCTClass(PyTango.DeviceClass):
    #--------- Add you global class variables here --------------------------
    #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.global_class_variables) ENABLED START -----#
    
    #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.global_class_variables

    def dyn_attr(self, dev_list):
        """Invoked to create dynamic attributes for the given devices.
        Default implementation calls
        :meth:`MeasuredFillingPatternFCT.initialize_dynamic_attributes` for each device
    
        :param dev_list: list of devices
        :type dev_list: :class:`PyTango.DeviceImpl`"""
    
        for dev in dev_list:
            try:
                dev.initialize_dynamic_attributes()
            except:
                import traceback
                dev.warn_stream("Failed to initialize dynamic attributes")
                dev.debug_stream("Details: " + traceback.format_exc())
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.dyn_attr) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.dyn_attr

    #    Class Properties
    class_property_list = {
        }


    #    Device Properties
    device_property_list = {
        'AutoStart':
            [PyTango.DevBoolean,
            "Configure if the device must start the calculation by default when it is launched",
            [True]],
        'FCTAttribute':
            [PyTango.DevString,
            "Channel of the scope from where the readings are get",
            [] ],
        'RfGeneratorAttr':
            [PyTango.DevString,
            "RfGenerator Attr name from where the frequency is read from time to time",
            [] ],
        'RfGeneratorDev':
            [PyTango.DevString,
            "RfGenerator Device name from where the frequency is read from time to time",
            [] ],
        'dcctAttr':
            [PyTango.DevString,
            "DCCT Attr name from where the sr current is read from time to time",
            ["AverageCurrent"] ],
        'dcctDev':
            [PyTango.DevString,
            "DCCT Device name from where the sr current is read from time to time",
            ["sr/di/dcct"] ],
        'erDev':
            [PyTango.DevString,
            "Event Receiver Device name",
            [] ],
        'scoDev':
            [PyTango.DevString,
            "Scope Device name where one channel has the FCT signal",
            [] ],
        }


    #    Command definitions
    cmd_list = {
        'Start':
            [[PyTango.DevVoid, "none"],
            [PyTango.DevVoid, "none"]],
        'Stop':
            [[PyTango.DevVoid, "none"],
            [PyTango.DevVoid, "none"]],
        'Exec':
            [[PyTango.DevString, "statement to executed"],
            [PyTango.DevString, "result"],
            {
                'Display level': PyTango.DispLevel.EXPERT,
            } ],
        }


    #    Attribute definitions
    attr_list = {
        'FilledBunches':
            [[PyTango.DevShort,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'label': "Filled Bunches",
            } ],
        'OffsetH':
            [[PyTango.DevDouble,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'label': "Oscilloscope Horizontal Offset",
                'unit': "s",
                'format': "%3.9f",
                'description': "Oscilloscope Horizontal Offset",
            } ],
        'OffsetH_expert':
            [[PyTango.DevDouble,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'label': "Oscilloscope Horizontal Offset",
                'unit': "s",
                'format': "%3.9f",
                'description': "Oscilloscope Horizontal Offset",
                'Display level': PyTango.DispLevel.EXPERT,
                'Memorized':"true"
            } ],
        'ScaleH':
            [[PyTango.DevDouble,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'label': "Oscilloscope Horizontal Scale",
                'unit': "s/div",
                'format': "%3.9f",
                'description': "Oscilloscope Horizontal Scale",
            } ],
        'ScaleH_expert':
            [[PyTango.DevDouble,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'label': "Oscilloscope Horizontal Scale",
                'unit': "s/div",
                'format': "%3.9f",
                'description': "Oscilloscope Horizontal Scale",
                'Display level': PyTango.DispLevel.EXPERT,
                'Memorized':"true"
            } ],
        'SpuriousBunches':
            [[PyTango.DevShort,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'label': "Spurious Bunches",
            } ],
        'StartingPoint':
            [[PyTango.DevShort,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'label': "Starting Point",
            } ],
        'StartingPoint_expert':
            [[PyTango.DevShort,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'label': "Starting Point",
                'Display level': PyTango.DispLevel.EXPERT,
                'Memorized':"true"
            } ],
        'Threshold':
            [[PyTango.DevDouble,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'label': "Threshold",
                'unit': "%",
                'max value': "100",
                'min value': "0",
            } ],
        'Threshold_expert':
            [[PyTango.DevDouble,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'label': "Threshold",
                'unit': "%",
                'max value': "100",
                'min value': "0",
                'Display level': PyTango.DispLevel.EXPERT,
                'Memorized':"true"
            } ],
        'TimingTrigger':
            [[PyTango.DevShort,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'label': "TimingTrigger",
                'unit': "ticks",
            } ],
        'TimingTrigger_expert':
            [[PyTango.DevShort,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'label': "Timing Trigger",
                'unit': "ticks",
                'Display level': PyTango.DispLevel.EXPERT,
                'Memorized':"true"
            } ],
        'emitCyclicBuffer':
            [[PyTango.DevBoolean,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'description': "This boolean attribute is to allow or not to emit the events on the cyclic Buffer. This is because it can cause delay dou to be too big buffer",
                'Display level': PyTango.DispLevel.EXPERT,
                'Memorized':"true"
            } ],
        'nAcquisitions':
            [[PyTango.DevUShort,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'label': "Number of acquisitions",
                'description': "Number of elements in the cyclic buffer from where the calculation takes the data.",
                'Memorized':"true"
            } ],
        'nBunches':
            [[PyTango.DevShort,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'label': "Number of Bunches",
            } ],
        'resultingFrequency':
            [[PyTango.DevDouble,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'label': "Resulting Frequency",
                'unit': "Hz",
                'format': "%3.3f",
                'description': "Expert attribute to read the frequency with this device is pushing results in the output",
                'Display level': PyTango.DispLevel.EXPERT,
            } ],
        'CurrentSampleRate':
            [[PyTango.DevDouble,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'label': "Current Sample Rate",
            } ],
        'BunchIntensity':
            [[PyTango.DevDouble,
            PyTango.SPECTRUM,
            PyTango.READ, 5000]],
        'CyclicBufferTrace':
            [[PyTango.DevString,
            PyTango.SPECTRUM,
            PyTango.READ, 10000],
            {
                'description': "Internal use attribute to have information about how the buffer changes",
                'Display level': PyTango.DispLevel.EXPERT,
            } ],
        'InputSignal':
            [[PyTango.DevDouble,
            PyTango.SPECTRUM,
            PyTango.READ, 65536]],
        'cyclicBuffer':
            [[PyTango.DevDouble,
            PyTango.IMAGE,
            PyTango.READ, 40000, 50],
            {
                'description': "Expert attribute to be able to check the cyclic buffer evolution",
                'Display level': PyTango.DispLevel.EXPERT,
            } ],
        }


def main():
    try:
        py = PyTango.Util(sys.argv)
        py.add_class(MeasuredFillingPatternFCTClass,MeasuredFillingPatternFCT,'MeasuredFillingPatternFCT')
        #----- PROTECTED REGION ID(MeasuredFillingPatternFCT.add_classes) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternFCT.add_classes

        U = PyTango.Util.instance()
        U.server_init()
        U.server_run()

    except PyTango.DevFailed,e:
        print '-------> Received a DevFailed exception:',e
    except Exception,e:
        print '-------> An unforeseen exception occured....',e

if __name__ == '__main__':
    main()
