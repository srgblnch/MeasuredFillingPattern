#!/usr/bin/env python
# -*- coding:utf-8 -*- 


##############################################################################
## license :
##============================================================================
##
## File :        MeasuredFillingPatternPhCt.py
## 
## Project :     Measured Filling Pattern from a Photon Counter
##
## This file is part of Tango device class.
## 
## Tango is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
## 
## Tango is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
## 
## You should have received a copy of the GNU General Public License
## along with Tango.  If not, see <http://www.gnu.org/licenses/>.
## 
##
## $Author :      sblanch$
##
## $Revision :    $
##
## $Date :        $
##
## $HeadUrl :     $
##============================================================================
##            This file is generated by POGO
##    (Program Obviously used to Generate tango Object)
##
##        (c) - Software Engineering Group - ESRF
##############################################################################

"""Device to ..."""

__all__ = ["MeasuredFillingPatternPhCt", "MeasuredFillingPatternPhCtClass", "main"]

__docformat__ = 'restructuredtext'

import PyTango
import sys
# Add additional import
#----- PROTECTED REGION ID(MeasuredFillingPatternPhCt.additionnal_import) ENABLED START -----#
import time
import threading
from phAnalyser import PhCtAnalyzer
import traceback

from types import StringType

META = u"""
    $URL: https://svn.code.sf.net/p/tango-ds/code/Servers/Calculation/MeasuredFillingPattern$
    $LastChangedBy: sergiblanch $
    License: GPL3+
    Author: Sergi Blanch
""".encode('latin1')


#----- PROTECTED REGION END -----#	//	MeasuredFillingPatternPhCt.additionnal_import

## Device States Description
## ALARM : Check the status, something is not running as expected, but the calculations are still alive.
## OFF : The device is alive, but is not reading anything, neither doing any calculation
## ON : Device is doing the calculation normally
## STANDBY : The calculation have start, but not with the expected #samples in the cyclic buffer 
## FAULT : Something out of the specs, calculation stopped. Check the status.
## INIT : Just when the device is launched until its build procedure is done

class MeasuredFillingPatternPhCt (PyTango.Device_4Impl):

    #--------- Add you global variables here --------------------------
    #----- PROTECTED REGION ID(MeasuredFillingPatternPhCt.global_variables) ENABLED START -----#
    def cleanAllImportantLogs(self):
        #@todo: clean the important logs when they loose importance.
        self.debug_stream("In %s::cleanAllImportantLogs()"%self.get_name())
        self._important_logs = []
        self.addStatusMsg("")

    def addStatusMsg(self,newMsg,isImportant=False):
        self.debug_stream("In %s::addStatusMsg('%s')"%(self.get_name(),newMsg))
        completeMsg = "The device is in %s state.\n"%(self.get_state())
        for ilog in self._important_logs:
            completeMsg = "%s%s\n"%(completeMsg,ilog)
        status = "%s%s\n"%(completeMsg,newMsg)
        self.set_status(status)
        self.push_change_event('Status',status)
        if isImportant and not newMsg in self._important_logs:
            self._important_logs.append(newMsg)

    def change_state(self,newstate):
        self.info_stream("In %s::change_state(%s)"
                         %(self.get_name(),str(newstate)))
        self.set_state(newstate)
        self.push_change_event('State',newstate)
        self.cleanAllImportantLogs()
        
    def createThread(self):
        self.debug_stream("In %s::createThread()"%self.get_name())
        #TODO: check if the thread can be created or if it is already created
        if not self.get_state() in [PyTango.DevState.OFF]:
            return False
        if hasattr(self,'_thread') and self._thread and self._thread.isAlive():
            self.debug_stream("In %s::createThread(): Trying to start "\
                              "threading when is already started."
                              %self.get_name())
            self.change_state(PyTango.DevState.FAULT)
            self.addStatusMsg("Try to start the calculation thread when is "\
                              "already running.",isImportant=True)
            return False
        msg = "Start calculation threading."
        self.debug_stream("In %s::createThread(): %s"%(self.get_name(),msg))
        try:
            self._joinerEvent = threading.Event()#to communicate between threads
            self._joinerEvent.clear()
            self._startCmd = threading.Event()#Start command has been received
            self._startCmd.clear()
            if self.AutoStart:
                self._startCmd.set()
            self._stopCmd = threading.Event()#Stop command has been received
            self._stopCmd.clear()
            self._thread = threading.Thread(target=self.analyzerThread)
            self._thread.setDaemon(True)
            self._thread.start()
            self.debug_stream("In %s::createThread(): Thread created."
                              %self.get_name())
        except Exception,e:
            self.warn_stream("In %s::createThread(): Exception creating "\
                             "thread: %s."%(self.get_name(),e))
            self.change_state(PyTango.DevState.FAULT)
            self.addStatusMsg("Exception creating calculation thread.",
                              isImportant=True)
            return False
        return True
    def deleteThread(self):
        self.debug_stream("In %s::deleteThread(): Stoping acquisition "\
                          "threading."%self.get_name())
        if hasattr(self,'_joinerEvent'):
            self.debug_stream("In %s::deleteThread(): sending join event."
                              %self.get_name())
            self._joinerEvent.set()
        if hasattr(self,'_thread'):
            self.debug_stream("In %s::deleteThread(): Thread joining."
                              %self.get_name())
            self._thread.join(1)
            if self._thread.isAlive():
                self.debug_stream("In %s::deleteThread(): Thread joined."
                                  %self.get_name())
    
    def analyzerThread(self):
        self.debug_stream("In %s::analyzerThread(): Thread started."
                          %self.get_name())
        if not hasattr(self,'_joinerEvent'):
            raise Exception("Not possible to start the loop because it have "\
                            "not end condition")
        self.change_state(PyTango.DevState.STANDBY)
        #FIXME: change the state when it starts to work
        self.cleanAllImportantLogs()
        self.addStatusMsg("Starting buffer population")
        #Build the analyzer object
        try:
            time.sleep(1)
            self.debug_stream("Build PhCtAnalyzer instance (%s)"%self.PhCtDev)
            self._bunchAnalyzer = PhCtAnalyzer(str(self.PhCtDev),
                                               dcctDev=self.dcctDev,
                                               dcctAttr=self.dcctAttr,
                                               parent=self)
            self.debug_stream("Build PhCtAnalyzer made (%s)"
                              %(self._bunchAnalyzer.PhCtDevName))
        except:
            self.change_state(PyTango.DevState.FAULT)
            self.addStatusMsg("Cannot build the analyzer",isImportant=True)
            traceback.print_exc()
            return
        while not self._joinerEvent.isSet():
            #TODO: passive wait until no new data is available
            #FIXME: can this start with less samples in the buffer than the 
            #       number configured in the nAcquisitions attribute?
            #TODO: if a loop takes too long ALARM state and a message
            try:
                if self._startCmd.isSet():
                    self._startCmd.clear()
                    if not self.get_state() in [PyTango.DevState.ON]:
                        try:
                            # Subscribe to events of the scope channel
                            #self._bunchAnalyzer.CyclicBuffer([])
                            self._bunchAnalyzer.subscribeHistogram()
                            self.change_state(PyTango.DevState.ON)
                            self.addStatusMsg("Subscribed to %s"
                                              %(self.PhCtAttr))
                        except Exception,e:
                            self.change_state(PyTango.DevState.FAULT)
                            self.addStatusMsg("Cannot subscribe to the PhCt",
                                              isImportant=True)
                            self.debug_stream("Cannot subscribe to the PhCt "\
                                              "due to: %s"%(e))
                            traceback.print_exc()
                if self._stopCmd.isSet():
                    self._stopCmd.clear()
                    if not self.get_state() in [PyTango.DevState.OFF]:
                        try:
                            pass
                            self._bunchAnalyzer.unsubscribeHistogram()
                            eventList = []
                            #eventList.append(['nAcquisitions',0])
                                #,PyTango.AttrQuality.ATTR_INVALID])
                            #eventList.append(['CyclicBuffer',[[0]]])
                                #,PyTango.AttrQuality.ATTR_INVALID])
                            eventList.append(['BunchIntensity',[0]])
                                #,PyTango.AttrQuality.ATTR_INVALID])
                            #eventList.append(['FilledBunches',0])
                                #,PyTango.AttrQuality.ATTR_INVALID])
                            #eventList.append(['SpuriousBunches',0])
                                #,PyTango.AttrQuality.ATTR_INVALID])
                            #eventList.append(['nBunches',0])
                                #,PyTango.AttrQuality.ATTR_INVALID])
                            #eventList.append(['resultingFrequency',0])
                                #,PyTango.AttrQuality.ATTR_INVALID])
                            eventList.append(['InputSignal',[0]])
                            self.fireEventsList(eventList)
                        except Exception,e:
                            self.change_state(PyTango.DevState.FAULT)
                            self.addStatusMsg("Cannot unsubscribe to the PhCt",
                                              isImportant=True)
                            self.debug_stream("Cannot unsubscribe to the PhCt"\
                                              " due to: %s"%(e))
                time.sleep(1)
            except Exception,e:
                self.error_stream("In %s::analyzerThread(): Exception: %s"
                                  %(self.get_name(),e))
            
            
    def fireEventsList(self,eventsAttrList):
        #self.debug_stream("In %s::fireEventsList()"%self.get_name())
        #@todo: add the value on the push_event
        timestamp = time.time()
        for attrEvent in eventsAttrList:
            try:
                self.debug_stream("In %s::fireEventsList() attribute: %s"
                                  %(self.get_name(),attrEvent[0]))
                if attrEvent[0] in ['CyclicBuffer'] and \
                not self.attr_emitCyclicBuffer_read:
                    self.debug_stream("In %s::fireEventsList() attribute: "\
                                      "%s avoided to emit the event duo to "\
                                      "flag."%(self.get_name(),attrEvent[0]))
                elif len(attrEvent) == 3:#specifies quality
                    self.push_change_event(attrEvent[0],attrEvent[1],
                                           timestamp,attrEvent[2])
                else:
                    self.push_change_event(attrEvent[0],attrEvent[1],timestamp,
                                           PyTango.AttrQuality.ATTR_VALID)
            except Exception,e:
                self.error_stream("In %s::fireEventsList() Exception with "\
                                 "attribute %s"%(self.get_name(),attrEvent[0]))
                print e
#----- PROTECTED REGION END -----#	//	MeasuredFillingPatternPhCt.global_variables

    def __init__(self,cl, name):
        PyTango.Device_4Impl.__init__(self,cl,name)
        self.debug_stream("In __init__()")
        MeasuredFillingPatternPhCt.init_device(self)
        #----- PROTECTED REGION ID(MeasuredFillingPatternPhCt.__init__) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternPhCt.__init__
        
    def delete_device(self):
        self.debug_stream("In delete_device()")
        #----- PROTECTED REGION ID(MeasuredFillingPatternPhCt.delete_device) ENABLED START -----#
        self.deleteThread()
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternPhCt.delete_device

    def init_device(self):
        self.debug_stream("In init_device()")
        self.get_device_properties(self.get_device_class())
        self.attr_Threshold_read = 0
        self.attr_Threshold_expert_read = 0
        self.attr_resultingFrequency_read = 0.0
        self.attr_nBunches_read = 0.0
        self.attr_BunchIntensity_read = [0.0]
        self.attr_InputSignal_read = [0.0]
        #----- PROTECTED REGION ID(MeasuredFillingPatternPhCt.init_device) ENABLED START -----#
        self.attr_threshold_write = 0
        self._important_logs = []
        self._bunchAnalyzer = None
        #tools for the Exec() cmd
        DS_MODULE = __import__(self.__class__.__module__)
        kM = dir(DS_MODULE)
        vM = map(DS_MODULE.__getattribute__, kM)
        self.__globals = dict(zip(kM, vM))
        self.__globals['self'] = self
        self.__globals['module'] = DS_MODULE
        self.__locals = {}
        #prepare attributes that will have events
        self.set_change_event('State', True, False)
        self.set_change_event('Status', True, False)
        self.set_change_event('BunchIntensity', True, False)
        self.set_change_event('InputSignal', True, False)
        self.set_change_event('resultingFrequency',True,False)
        #prepare the analyzer thread
        self.change_state(PyTango.DevState.OFF)
        if self.createThread():
            self.addStatusMsg("Analyzer thread well created")
        else:
            self.change_state(PyTango.DevState.FAULT)
            self.cleanAllImportantLogs()
            self.addStatusMsg("Analyzer thread cannot be created")
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternPhCt.init_device

    def always_executed_hook(self):
        self.debug_stream("In always_excuted_hook()")
        #----- PROTECTED REGION ID(MeasuredFillingPatternPhCt.always_executed_hook) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternPhCt.always_executed_hook

    #-----------------------------------------------------------------------------
    #    MeasuredFillingPatternPhCt read/write attribute methods
    #-----------------------------------------------------------------------------
    
    def read_Threshold(self, attr):
        self.debug_stream("In read_Threshold()")
        #----- PROTECTED REGION ID(MeasuredFillingPatternPhCt.Threshold_read) ENABLED START -----#
        try:
            self.attr_threshold_read = self._bunchAnalyzer.threshold
        except:
            self.warn_stream("In read_BunchIntensity() cannot get from "\
                             "BunchAnalyzer()")
        attr.set_value(self.attr_Threshold_read)
        
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternPhCt.Threshold_read
        
    def is_Threshold_allowed(self, attr):
        self.debug_stream("In is_Threshold_allowed()")
        if attr==PyTango.AttReqType.READ_REQ:
            state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
                PyTango.DevState.INIT])
        else:
            state_ok = not(self.get_state() in [])
        #----- PROTECTED REGION ID(MeasuredFillingPatternPhCt.is_Threshold_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternPhCt.is_Threshold_allowed
        return state_ok
        
    def read_Threshold_expert(self, attr):
        self.debug_stream("In read_Threshold_expert()")
        #----- PROTECTED REGION ID(MeasuredFillingPatternPhCt.Threshold_expert_read) ENABLED START -----#
        try:
            self.attr_threshold_expert_read = self._bunchAnalyzer.threshold
        except:
            self.warn_stream("In read_BunchIntensity() cannot get from "\
                             "BunchAnalyzer()")
        attr.set_value(self.attr_threshold_expert_read)
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternPhCt.Threshold_expert_read
        
    def write_Threshold_expert(self, attr):
        self.debug_stream("In write_Threshold_expert()")
        data=attr.get_write_value()
        #----- PROTECTED REGION ID(MeasuredFillingPatternPhCt.Threshold_expert_write) ENABLED START -----#
        self.attr_threshold_expert_read = int(data)
        self.attr_threshold_write = self.attr_threshold_expert_read
        try:
            self._bunchAnalyzer.threshold = self.attr_threshold_write
            self.attr_threshold_read = self._bunchAnalyzer.threshold
        except:
            self.warn_stream("In write_threshold() cannot set in "\
                             "BunchAnalyzer()")
        self.fireEventsList([['Threshold',self.attr_Threshold_read]])
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternPhCt.Threshold_expert_write
        
    def is_Threshold_expert_allowed(self, attr):
        self.debug_stream("In is_Threshold_expert_allowed()")
        if attr==PyTango.AttReqType.READ_REQ:
            state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
                PyTango.DevState.INIT])
        else:
            state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
                PyTango.DevState.INIT])
        #----- PROTECTED REGION ID(MeasuredFillingPatternPhCt.is_Threshold_expert_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternPhCt.is_Threshold_expert_allowed
        return state_ok
        
    def read_resultingFrequency(self, attr):
        self.debug_stream("In read_resultingFrequency()")
        #----- PROTECTED REGION ID(MeasuredFillingPatternPhCt.resultingFrequency_read) ENABLED START -----#
        try:
            self.attr_resultingFrequency_read = self._bunchAnalyzer.ResultingFrequency
        except:
            self.warn_stream("In read_resultingFrequency() cannot get from BunchAnalyzer()")
        attr.set_value(self.attr_resultingFrequency_read)
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternPhCt.resultingFrequency_read
        
    def is_resultingFrequency_allowed(self, attr):
        self.debug_stream("In is_resultingFrequency_allowed()")
        if attr==PyTango.AttReqType.READ_REQ:
            state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
                PyTango.DevState.INIT])
        else:
            state_ok = not(self.get_state() in [])
        #----- PROTECTED REGION ID(MeasuredFillingPatternPhCt.is_resultingFrequency_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternPhCt.is_resultingFrequency_allowed
        return state_ok
        
    def read_nBunches(self, attr):
        self.debug_stream("In read_nBunches()")
        #----- PROTECTED REGION ID(MeasuredFillingPatternPhCt.nBunches_read) ENABLED START -----#
        attr.set_value(self.attr_nBunches_read)
        
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternPhCt.nBunches_read
        
    def is_nBunches_allowed(self, attr):
        self.debug_stream("In is_nBunches_allowed()")
        if attr==PyTango.AttReqType.READ_REQ:
            state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
                PyTango.DevState.INIT])
        else:
            state_ok = not(self.get_state() in [])
        #----- PROTECTED REGION ID(MeasuredFillingPatternPhCt.is_nBunches_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternPhCt.is_nBunches_allowed
        return state_ok
        
    def read_BunchIntensity(self, attr):
        self.debug_stream("In read_BunchIntensity()")
        #----- PROTECTED REGION ID(MeasuredFillingPatternPhCt.BunchIntensity_read) ENABLED START -----#
        try:
            self.attr_BunchIntensity_read = self._bunchAnalyzer.BunchIntensity
        except:
            self.warn_stream("In read_BunchIntensity() cannot get from "\
                             "BunchAnalyzer()")
        attr.set_value(self.attr_BunchIntensity_read)
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternPhCt.BunchIntensity_read
        
    def is_BunchIntensity_allowed(self, attr):
        self.debug_stream("In is_BunchIntensity_allowed()")
        if attr==PyTango.AttReqType.READ_REQ:
            state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
                PyTango.DevState.INIT])
        else:
            state_ok = not(self.get_state() in [])
        #----- PROTECTED REGION ID(MeasuredFillingPatternPhCt.is_BunchIntensity_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternPhCt.is_BunchIntensity_allowed
        return state_ok
        
    def read_InputSignal(self, attr):
        self.debug_stream("In read_InputSignal()")
        #----- PROTECTED REGION ID(MeasuredFillingPatternPhCt.InputSignal_read) ENABLED START -----#
        try:
            self.attr_InputSignal_read = self._bunchAnalyzer.InputSignal
        except:
            self.warn_stream("In read_InputSignal() cannot get from "\
                             "BunchAnalyzer()")
        attr.set_value(self.attr_InputSignal_read)
        
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternPhCt.InputSignal_read
        
    def is_InputSignal_allowed(self, attr):
        self.debug_stream("In is_InputSignal_allowed()")
        if attr==PyTango.AttReqType.READ_REQ:
            state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
                PyTango.DevState.INIT])
        else:
            state_ok = not(self.get_state() in [])
        #----- PROTECTED REGION ID(MeasuredFillingPatternPhCt.is_InputSignal_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternPhCt.is_InputSignal_allowed
        return state_ok
        
    
    
        #----- PROTECTED REGION ID(MeasuredFillingPatternPhCt.initialize_dynamic_attributes) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternPhCt.initialize_dynamic_attributes
            
    def read_attr_hardware(self, data):
        self.debug_stream("In read_attr_hardware()")
        #----- PROTECTED REGION ID(MeasuredFillingPatternPhCt.read_attr_hardware) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternPhCt.read_attr_hardware


    #-----------------------------------------------------------------------------
    #    MeasuredFillingPatternPhCt command methods
    #-----------------------------------------------------------------------------
    
    def Start(self):
        """ 
        
        :param : 
        :type: PyTango.DevVoid
        :return: 
        :rtype: PyTango.DevVoid """
        self.debug_stream("In Start()")
        #----- PROTECTED REGION ID(MeasuredFillingPatternPhCt.Start) ENABLED START -----#
        self._startCmd.set()
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternPhCt.Start
        
    def is_Start_allowed(self):
        self.debug_stream("In is_Start_allowed()")
        state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
            PyTango.DevState.INIT])
        #----- PROTECTED REGION ID(MeasuredFillingPatternPhCt.is_Start_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternPhCt.is_Start_allowed
        return state_ok
        
    def Stop(self):
        """ 
        
        :param : 
        :type: PyTango.DevVoid
        :return: 
        :rtype: PyTango.DevVoid """
        self.debug_stream("In Stop()")
        #----- PROTECTED REGION ID(MeasuredFillingPatternPhCt.Stop) ENABLED START -----#
        self._stopCmd.set()
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternPhCt.Stop
        
    def is_Stop_allowed(self):
        self.debug_stream("In is_Stop_allowed()")
        state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
            PyTango.DevState.INIT])
        #----- PROTECTED REGION ID(MeasuredFillingPatternPhCt.is_Stop_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternPhCt.is_Stop_allowed
        return state_ok
        
    def Exec(self, argin):
        """ 
        
        :param argin: statement to executed
        :type: PyTango.DevString
        :return: result
        :rtype: PyTango.DevString """
        self.debug_stream("In Exec()")
        argout = ''
        #----- PROTECTED REGION ID(MeasuredFillingPatternPhCt.Exec) ENABLED START -----#
        try:
            try:
                # interpretation as expression
                argout = eval(argin,self.__globals,self.__locals)
            except SyntaxError:
                # interpretation as statement
                exec argin in self.__globals, self.__locals
                argout = self.__locals.get("y")

        except Exception, exc:
            # handles errors on both eval and exec level
            argout = traceback.format_exc()

        if type(argout)==StringType:
            return argout
        elif isinstance(argout, BaseException):
            return "%s!\n%s" % (argout.__class__.__name__, str(argout))
        else:
            try:
                return pprint.pformat(argout)
            except Exception:
                return str(argout)
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternPhCt.Exec
        return argout
        

    #----- PROTECTED REGION ID(MeasuredFillingPatternPhCt.programmer_methods) ENABLED START -----#
    def initialize_dynamic_attributes(self):
        pass
    #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternPhCt.programmer_methods

class MeasuredFillingPatternPhCtClass(PyTango.DeviceClass):
    #--------- Add you global class variables here --------------------------
    #----- PROTECTED REGION ID(MeasuredFillingPatternPhCt.global_class_variables) ENABLED START -----#
    
    #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternPhCt.global_class_variables

    def dyn_attr(self, dev_list):
        """Invoked to create dynamic attributes for the given devices.
        Default implementation calls
        :meth:`MeasuredFillingPatternPhCt.initialize_dynamic_attributes` for each device
    
        :param dev_list: list of devices
        :type dev_list: :class:`PyTango.DeviceImpl`"""
    
        for dev in dev_list:
            try:
                dev.initialize_dynamic_attributes()
            except:
                import traceback
                dev.warn_stream("Failed to initialize dynamic attributes")
                dev.debug_stream("Details: " + traceback.format_exc())
        #----- PROTECTED REGION ID(MeasuredFillingPatternPhCt.dyn_attr) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternPhCt.dyn_attr

    #    Class Properties
    class_property_list = {
        }


    #    Device Properties
    device_property_list = {
        'PhCtDev':
            [PyTango.DevString,
            "Photon Counter device name",
            [] ],
        'AutoStart':
            [PyTango.DevBoolean,
            "Configure if the device must start the calculation by default when it is launched",
            [True]],
        'PhCtAttr':
            [PyTango.DevString,
            "Photon Counter histogram property name",
            [] ],
        'dcctAttr':
            [PyTango.DevString,
            "DCCT Attr name from where the sr current is read from time to time",
            ["AverageCurrent"] ],
        'dcctDev':
            [PyTango.DevString,
            "DCCT Device name from where the sr current is read from time to time",
            ["sr/di/dcct"] ],
        }


    #    Command definitions
    cmd_list = {
        'Start':
            [[PyTango.DevVoid, "none"],
            [PyTango.DevVoid, "none"]],
        'Stop':
            [[PyTango.DevVoid, "none"],
            [PyTango.DevVoid, "none"]],
        'Exec':
            [[PyTango.DevString, "statement to executed"],
            [PyTango.DevString, "result"],
            {
                'Display level': PyTango.DispLevel.EXPERT,
            } ],
        }


    #    Attribute definitions
    attr_list = {
        'Threshold':
            [[PyTango.DevUShort,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'label': "Threshold",
                'unit': "%",
                'max value': "100",
                'min value': "0",
            } ],
        'Threshold_expert':
            [[PyTango.DevUShort,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'label': "Threshold",
                'unit': "%",
                'max value': "100",
                'min value': "0",
                'Display level': PyTango.DispLevel.EXPERT,
                'Memorized':"true"
            } ],
        'resultingFrequency':
            [[PyTango.DevDouble,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'label': "Resulting Frequency",
                'unit': "Hz",
                'format': "%3.3f",
                'description': "Expert attribute to read the frequency with this device is pushing results in the output",
                'Display level': PyTango.DispLevel.EXPERT,
            } ],
        'nBunches':
            [[PyTango.DevDouble,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'label': "Number of Bunches",
            } ],
        'BunchIntensity':
            [[PyTango.DevDouble,
            PyTango.SPECTRUM,
            PyTango.READ, 5000]],
        'InputSignal':
            [[PyTango.DevDouble,
            PyTango.SPECTRUM,
            PyTango.READ, 65536]],
        }


def main():
    try:
        py = PyTango.Util(sys.argv)
        py.add_class(MeasuredFillingPatternPhCtClass,MeasuredFillingPatternPhCt,'MeasuredFillingPatternPhCt')
        #----- PROTECTED REGION ID(MeasuredFillingPatternPhCt.add_classes) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	MeasuredFillingPatternPhCt.add_classes

        U = PyTango.Util.instance()
        U.server_init()
        U.server_run()

    except PyTango.DevFailed,e:
        print '-------> Received a DevFailed exception:',e
    except Exception,e:
        print '-------> An unforeseen exception occured....',e

if __name__ == '__main__':
    main()
